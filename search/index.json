[{"content":"摸了几天后继续开始！\n二叉树基础知识 二叉树的种类 满二叉树 完全二叉树 二叉搜索树 平衡搜索二叉树 二叉搜索树 二叉搜索树是一个有序树。\n若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树 即：根节点为中值\n平衡二叉搜索树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\n二叉树的遍历 主要有两种：\n深度优先 广度优先 深度：前中后序遍历\n广度：层次遍历\n二叉树的定义 Cpp:\nstruct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 二叉树的递归遍历 递归的要素 确定递归函数的参数和返回值 确定中止条件 确定单层递归的逻辑 144. Binary Tree Preorder Traversal Cpp：\nclass Solution { public: void truePreorderTraversal(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; result){ if(root==nullptr) return; result.push_back(root-\u0026gt;val); truePreorderTraversal(root-\u0026gt;left,result); truePreorderTraversal(root-\u0026gt;right,result); } vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; truePreorderTraversal(root,result); return result; } }; Go：\nfunc truePreorderTraversal(root *TreeNode, result *[]int){ // 需要注意的是Go中只有值传递，需要传入指针 if root==nil{ return } *result = append(*result,root.Val) truePreorderTraversal(root.Left,result) truePreorderTraversal(root.Right,result) } func preorderTraversal(root *TreeNode) []int { result := []int{} truePreorderTraversal(root,\u0026amp;result) return result } 145. Binary Tree Postorder Traversal Go：\nfunc postorderTraversal(root *TreeNode) []int { res := []int{} var trueTraversal func(root *TreeNode) // 也可以定义内建函数 trueTraversal = func(root *TreeNode){ if root==nil{ return } trueTraversal(root.Left) trueTraversal(root.Right) res = append(res,root.Val) } trueTraversal(root) return res } Cpp：\nclass Solution { public: void trueTraversal(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; result){ if(root==nullptr) return; trueTraversal(root-\u0026gt;left,result); trueTraversal(root-\u0026gt;right,result); result.push_back(root-\u0026gt;val); } vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; trueTraversal(root,res); return res; } }; 94. Binary Tree Inorder Traversal Cpp:\nclass Solution { public: void trueInorderTraversal(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; result){ if(root==nullptr) return; trueInorderTraversal(root-\u0026gt;left,result); result.push_back(root-\u0026gt;val); trueInorderTraversal(root-\u0026gt;right,result); } vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; trueInorderTraversal(root,result); return result; } }; Go的话就摸了\n二叉树的迭代遍历 我们之前用的都是二叉树的递归遍历，而我们知道，递归是用栈实现的，每次调用都会把函数的局部变量、参数和返回地址入栈。\n前序遍历 根节点入栈，然后，循环取头节点出栈，其右左节点入栈，直到栈空\n前序遍历的代码实现 Cpp:\nclass Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { stack\u0026lt;TreeNode*\u0026gt; nodeStack; vector\u0026lt;int\u0026gt; result; if (root == nullptr) return result; nodeStack.push(root); while(!nodeStack.empty()){ TreeNode* node = nodeStack.top(); nodeStack.pop(); result.push_back(node-\u0026gt;val); if (node-\u0026gt;right) nodeStack.push(node-\u0026gt;right); if (node-\u0026gt;left) nodeStack.push(node-\u0026gt;left); } return result; } }; 中序遍历 那么，中序遍历是否能和先序遍历一样简单呢？\n显然，是不行的，因为这样就无法像先序遍历一样，每次都取栈顶元素了\n首先，我们得明确两个操作：\n处理：将元素纳入result数组中 访问：遍历节点 之前写的先序遍历代码，先访问和先处理的是同一个节点，所以可以写出相对简洁的代码\n而到了中序遍历，就需要访问和处理顺序就不一样了，需要借用指针来帮助访问节点，栈来处理节点上的元素\n中序遍历的代码实现 Cpp：\nclass Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; stack\u0026lt;TreeNode*\u0026gt; nodeStack; // 借助指针访问节点 TreeNode* cur = root; while (cur!=nullptr||! nodeStack.empty()){ if (cur!=nullptr){ // 指针访问节点，直到最底层 nodeStack.push(cur); cur = cur-\u0026gt;left; // 继续访问左节点 } else { cur = nodeStack.top(); nodeStack.pop(); result.push_back(cur-\u0026gt;val); cur = cur-\u0026gt;right; } } return result; } }; 后序遍历 知道了中序遍历，那么后序遍历就很简单了，只需要对前序遍历稍作修改\n中左右-\u0026gt;中右左\n然后，反转result数组，就可以得到左右中\n后序遍历的代码实现 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { stack\u0026lt;TreeNode*\u0026gt; nodeStack; vector\u0026lt;int\u0026gt; result; if (root==nullptr) return result; nodeStack.push(root); while(!nodeStack.empty()){ TreeNode* node = nodeStack.top(); nodeStack.pop(); result.push_back(node-\u0026gt;val); if(node-\u0026gt;left) nodeStack.push(node-\u0026gt;left); if(node-\u0026gt;right) nodeStack.push(node-\u0026gt;right); } reverse(result.begin(),result.end()); return result; } }; 二叉树的统一迭代法 那么，有没有一种统一的风格解决二叉树的迭代遍历呢？\n是有的\n我们知道，中序遍历时，访问和处理顺序不一样，需要借用指针来帮助访问节点\n可以将访问的节点放进栈中，处理的节点同样入栈，但是需要接着放入空指针作为标记\n这里没意思，先跳\n二叉树的层序遍历 层序遍历，即从左到右一层层遍历二叉树，需要使用队列来辅助实现\n先进先出，符合一层层遍历的逻辑\n也就是说，这是一种广度优先遍历\n思想非常简单：\n根节点入队 首节点出队，其左右子节点入队 如此反复直到队列为空 102. Binary Tree Level Order Traversal 题目链接\nGiven the root of a binary tree, return the level order traversal of its nodes\u0026rsquo; values. (i.e., from left to right, level by level).\n循环法 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt; que; // 根非空加入队列 if(root!=nullptr) que.push(root); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; // 循环至队空 while (!que.empty()){ int size = que.size(); vector\u0026lt;int\u0026gt; layer; for(int i=0;i\u0026lt;size;i++){ // 头节点出队 TreeNode* node = que.front(); que.pop(); // 处理头节点 layer.push_back(node-\u0026gt;val); if(node-\u0026gt;left) que.push(node-\u0026gt;left); if(node-\u0026gt;right) que.push(node-\u0026gt;right); } result.push_back(layer); } return result; } }; 递归法 Solution { public: void order(TreeNode* cur,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; result, int depth){ if(cur==nullptr) return; if(result.size()==depth) // size达到深度扩容 result.push_back(vector\u0026lt;int\u0026gt;()); result[depth].push_back(cur-\u0026gt;val); order(cur-\u0026gt;left,result,depth+1); order(cur-\u0026gt;right,result,depth+1); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; int depth = 0; order(root,result,depth); return result; } }; 226. Invert Binary Tree 又是一道有梗的题目\nGiven the root of a binary tree, invert the tree, and return its root.\n怎么做呢？\n其实很简单，把所有节点的左右子节点交换一下就好了\n不过，值得注意的是，中序遍历会交换两次\nclass Solution { public: TreeNode* invertTree(TreeNode* root) { if(root==nullptr) return root; swap(root-\u0026gt;left,root-\u0026gt;right); invertTree(root-\u0026gt;left); invertTree(root-\u0026gt;right); return root; } }; func invertTree(root *TreeNode) *TreeNode { if root==nil{ return root } root.Left,root.Right = root.Right,root.Left invertTree(root.Left) invertTree(root.Right) return root } 看来那个被谷歌拒的大神应该是根本没准备算法题\n101. Symmetric Tree Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\n101.思路 嗯哼，层序遍历然后看对不对称是吧？\n不，并不行，需要是镜像对称的，详见样例\n我们需要比较二叉树的“里侧”和“外侧”是不是相同，也就是，以不同的顺序遍历根节点的左右子节点\n遍历顺序的都是后序遍历，即：左节点左右中，右节点右左中\n为什么是后序呢？\n因为需要先判断子节点，然后再返回上一级节点\n好吧，其实我在这里也是一知半解，先看看代码吧\n101.代码实现 class Solution { public: bool compare(TreeNode* left, TreeNode* right){ // 判断是否为空 if(left==nullptr\u0026amp;\u0026amp;right==nullptr) return true; if((left==nullptr\u0026amp;\u0026amp;right!=nullptr)||(left!=nullptr\u0026amp;\u0026amp;right==nullptr)) return false; // 判断值 if(left-\u0026gt;val!=right-\u0026gt;val) return false; // 进入下一层 return compare(left-\u0026gt;left,right-\u0026gt;right)\u0026amp;\u0026amp;compare(left-\u0026gt;right,right-\u0026gt;left); } bool isSymmetric(TreeNode* root) { if(root==nullptr) return true; return compare(root-\u0026gt;left,root-\u0026gt;right); } }; 同样地，也可以使用迭代法，但是需要用到队列\nclass Solution { public: bool isSymmetric(TreeNode* root) { if(root==nullptr) return true; queue\u0026lt;TreeNode*\u0026gt; que; que.push(root-\u0026gt;left); que.push(root-\u0026gt;right); while(!que.empty()){ TreeNode* leftNode = que.front(); que.pop(); TreeNode* rightNode = que.front(); que.pop(); // 同时为空，说明对称 if(leftNode==nullptr\u0026amp;\u0026amp;rightNode==nullptr) continue; // 若不同返回 if((leftNode==nullptr\u0026amp;\u0026amp;rightNode!=nullptr)||(leftNode!=nullptr\u0026amp;\u0026amp;rightNode==nullptr)) return false; if(leftNode-\u0026gt;val!=rightNode-\u0026gt;val) return false; // 入队左右子节点 que.push(leftNode-\u0026gt;left); que.push(rightNode-\u0026gt;right); que.push(leftNode-\u0026gt;right); que.push(rightNode-\u0026gt;left); } return true; } }; 嗯，这里的queue换成stack其实也行\n104. Maximum Depth of Binary Tree 这真的不是遍历的时候带一个层数吗？\nclass Solution { public: int maxdepth = 0; void traversal(TreeNode* root,int currDepth){ if(root==nullptr) return; if (currDepth\u0026gt;maxdepth){ maxdepth = currDepth; } traversal(root-\u0026gt;left,currDepth+1); traversal(root-\u0026gt;right,currDepth+1); } int maxDepth(TreeNode* root) { traversal(root,1); return maxdepth; } }; Note: 还可以层序遍历\n// 又有三周没动了，我这个自制力……\n","date":"2023-02-05","permalink":"https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A3%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":["力扣"],"title":"力扣二叉树"},{"content":"嘟嘟嘟，看看这次进展能不能快一点\n栈和队列，学过数据结构肯定记得是怎么样的，就不多讲了……\n232.Implement Queue using Stacks 1.题目描述 Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).\nImplement the MyQueue class:\nvoid push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise.\n1.解题思路 上数据结构的时候我做过！\n一个栈作为输入，一个栈作为输出就好了！\n就这样，我们轻松地写出了结构体和入队！\ntype MyQueue struct { inStack []int outStack []int } func Constructor() MyQueue { return MyQueue{} } func (this *MyQueue) Push(x int) { this.inStack = append(this.inStack,x) } 可是，怎么出队呢？(ﾟ∀。)\n（看了看解析后）原来如此，这两个栈合起来是一个队列\n所以，当我们需要出队的时候，需要一个in2out函数将这些输入栈里面全部的内容加入到输出栈里面\n准确地说，是将输入栈里面的内容一个个弹出，再一个个加入输出栈\n噗，实现的时候直接把切片append过去了，这是不符合栈的要求的，而且结果也不对\n1.代码实现 Go:\ntype MyQueue struct { // Go结构体声明就好了 inStack []int outStack []int } func Constructor() MyQueue { return MyQueue{} } func (this *MyQueue) Push(x int) { this.inStack = append(this.inStack,x) } func (this *MyQueue) in2out() { for len(this.inStack)\u0026gt;0{ // 将输入栈内容弹出，加入到输出栈 this.outStack = append(this.outStack,this.inStack[len(this.inStack)-1]) // 缩小输入栈 this.inStack = this.inStack[:len(this.inStack)-1] } } func (this *MyQueue) Pop() int { if len(this.outStack)==0{ // 只有输出栈为空时才转移 this.in2out() } res := this.outStack[len(this.outStack)-1] this.outStack = this.outStack[:len(this.outStack)-1] return res } func (this *MyQueue) Peek() int { res := this.Pop() // 复用Pop() this.outStack = append(this.outStack,res) return res } func (this *MyQueue) Empty() bool { if len(this.inStack) == 0\u0026amp;\u0026amp;len(this.outStack) == 0{ return true } return false } /** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ Cpp:\n只是敲一遍熟悉语法……\nclass MyQueue { public: stack\u0026lt;int\u0026gt; inStack; stack\u0026lt;int\u0026gt; outStack; MyQueue() { } void push(int x) { inStack.push(x); } int pop() { if(outStack.empty()){ while(!inStack.empty()){ outStack.push(inStack.top()); inStack.pop(); } } int res = outStack.top(); outStack.pop(); return res; } int peek() { int res = this-\u0026gt;pop(); // 只能用箭头吗……？ outStack.push(res); return res; } bool empty() { return outStack.empty()\u0026amp;\u0026amp;inStack.empty(); } }; /** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-\u0026gt;push(x); * int param_2 = obj-\u0026gt;pop(); * int param_3 = obj-\u0026gt;peek(); * bool param_4 = obj-\u0026gt;empty(); */ 225. Implement Stack using Queues 2.题目描述 Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).\nImplement the MyStack class:\nvoid push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise.\n2.解题思路 坏了，不知道\n好的，我知道了，用两个队列，一个拿来存储，一个出栈的时候存储转移前面几个\n2.代码实现 func (this *MyStack) Pop() int { res := 0 // 逐个出队入temp队列 for len(this.stackQueue)\u0026gt;1{ this.tempQueue = append(this.tempQueue,this.stackQueue[0]) this.stackQueue=this.stackQueue[1:] } // pop最后一个 res = this.stackQueue[0] this.stackQueue = make([]int,len(this.tempQueue)) // 然后tempQueue再倒回来 for len(this.stackQueue)\u0026gt;0{ this.tempQueue = append(this.tempQueue,this.stackQueue[0]) this.stackQueue=this.tempQueue[1:] } return res } 似乎for len(this.stackQueue)\u0026gt;0这里不太行……\n噢，可以用一个size来判断\nGo:\ntype MyStack struct { stackQueue []int tempQueue []int } func Constructor() MyStack { return MyStack{} } func (this *MyStack) Push(x int) { this.stackQueue = append(this.stackQueue,x) } func (this *MyStack) Pop() int { res := 0 // 逐个出队入temp队列 for len(this.stackQueue)\u0026gt;1{ this.tempQueue = append(this.tempQueue,this.stackQueue[0]) this.stackQueue=this.stackQueue[1:] } // pop最后一个 res = this.stackQueue[0] this.stackQueue = this.stackQueue[1:] // 然后tempQueue再倒回来 for size:=len(this.tempQueue);size\u0026gt;0;size--{ this.stackQueue = append(this.stackQueue,this.tempQueue[0]) this.tempQueue=this.tempQueue[1:] } return res } func (this *MyStack) Top() int { return this.stackQueue[len(this.stackQueue)-1] } func (this *MyStack) Empty() bool { if len(this.stackQueue)==0{ return true } return false } /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ Cpp:\nclass MyStack { queue\u0026lt;int\u0026gt; stackQueue; queue\u0026lt;int\u0026gt; tempQueue; public: MyStack() { return ; } void push(int x) { stackQueue.push(x); } int pop() { for(int size=stackQueue.size();size\u0026gt;1;--size){ tempQueue.push(stackQueue.front()); stackQueue.pop(); } int res = stackQueue.front(); stackQueue.pop(); while(!tempQueue.empty()){ stackQueue.push(tempQueue.front()); tempQueue.pop(); } return res; } int top() { return stackQueue.back(); } bool empty() { return stackQueue.empty(); } }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-\u0026gt;push(x); * int param_2 = obj-\u0026gt;pop(); * int param_3 = obj-\u0026gt;top(); * bool param_4 = obj-\u0026gt;empty(); */ 一个队列的解法 什么，还能这样！\n思路就是，pop的时候把前面的塞到队尾\n草草草\nGo：\nfunc (this *MyStack) Pop() int { res := 0 // 逐个出队入队尾 for size:=len(this.stackQueue);size\u0026gt;1;size--{ this.stackQueue = append(this.stackQueue,this.stackQueue[0]) this.stackQueue=this.stackQueue[1:] } // pop最后一个 res = this.stackQueue[0] this.stackQueue = this.stackQueue[1:] return res } Cpp：\nint pop() { for(int size=stackQueue.size();size\u0026gt;1;--size){ stackQueue.push(stackQueue.front()); stackQueue.pop(); } int res = stackQueue.front(); stackQueue.pop(); return res; } 20. Valid Parentheses 3.题目描述 Given a string s containing just the characters \u0026lsquo;(\u0026rsquo;, \u0026lsquo;)\u0026rsquo;, \u0026lsquo;{\u0026rsquo;, \u0026lsquo;}\u0026rsquo;, \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]\u0026rsquo;, determine if the input string is valid.\nAn input string is valid if:\nOpen brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type.\n3.解题思路 这题我会！遍历字符串统计数量就好了！\nclass Solution: def isValid(self, s: str) -\u0026gt; bool: count1,count2,count3 = 0,0,0 for i in s: if i == '(': count1+=1 if i == '[': count2+=1 if i == '{': count3+=1 if i == ')': count1-=1 if i == ']': count2-=1 if i == '}': count3-=1 if count1\u0026gt;1 or count1\u0026lt;-1: return False if count2\u0026gt;1 or count2\u0026lt;-1: return False if count3\u0026gt;1 or count3\u0026lt;-1: return False if count1==0 and count2 == 0 and count3 == 0: return True return False 然而卡在了\u0026quot;([)]\u0026quot;，而且也不符合大标题栈，那就摸了\n首先，我们得分析一下有哪些不匹配的情况：\n字符串里左方向的括号多余了，如\u0026quot;(([{}])\u0026quot; 字符串里右方向的括号多余了，如\u0026quot;([{}]))\u0026quot; 括号没有多余，但是括号的类型没有匹配上，如\u0026quot;([)]\u0026quot; 3.代码实现 值得注意的是，这里匹配左括号，但是是对应的右括号入栈，这样方便比较\nCpp：\nclass Solution { public: bool isValid(string s) { if (s.size()%2!=0) return false; stack\u0026lt;char\u0026gt; parenthesesStack; for (auto i : s){ if(i=='(') parenthesesStack.push(')'); else if (i=='[') parenthesesStack.push(']'); else if (i=='{') parenthesesStack.push('}'); // 如果栈为空（单独右括号）或者直接对不上，则说明无法匹配 else if (parenthesesStack.empty()||parenthesesStack.top()!=i) return false; // 右括号匹配成功，出栈 else parenthesesStack.pop(); } return parenthesesStack.empty(); } }; Go：\n复制粘贴的，更妙一点，用了Map省了很多if\nfunc isValid(s string) bool { hash := map[byte]byte{')':'(', ']':'[', '}':'{'} stack := make([]byte, 0) if s == \u0026quot;\u0026quot; { return true } for i := 0; i \u0026lt; len(s); i++ { if s[i] == '(' || s[i] == '[' || s[i] == '{' { stack = append(stack, s[i]) } else if len(stack) \u0026gt; 0 \u0026amp;\u0026amp; stack[len(stack)-1] == hash[s[i]] { stack = stack[:len(stack)-1] } else { return false } } return len(stack) == 0 } 1047. Remove All Adjacent Duplicates In String 4.题目描述 You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.\nWe repeatedly make duplicate removals on s until we no longer can.\nReturn the final string after all such duplicate removals have been made. It can be proven that the answer is unique.\n4.解题思路 想到了，跟上一题一样，将字符串一个个入栈，如果将入栈的字符和栈顶一致，就消掉\n4.代码实现 class Solution { public: string removeDuplicates(string s) { stack\u0026lt;char\u0026gt; charStack; for (auto c:s){ if (charStack.top()==c){ charStack.pop(); } else{ charStack.push(c); } } string res = \u0026quot;\u0026quot;; while(!charStack.empty()){ res+=charStack.top(); charStack.pop(); } reverse(res.begin(),res.end()); return res; } }; 但是这样报了AddressSanitizer:DEADLYSIGNAL，猜测应该是空的stack不能top\n很好，通过了\nclass Solution { public: string removeDuplicates(string s) { stack\u0026lt;char\u0026gt; charStack; for (auto c:s){ if(charStack.empty()||charStack.top()!=c){ charStack.push(c); } else{ charStack.pop(); } } string res = \u0026quot;\u0026quot;; while(!charStack.empty()){ res+=charStack.top(); charStack.pop(); } reverse(res.begin(),res.end()); return res; } }; 此外，还可以直接把结果字符串作为栈使用\nclass Solution { public: string removeDuplicates(string s) { string res = \u0026quot;\u0026quot;; for (auto c:s){ if(res.empty()||res.back()!=c){ res+=c; } else{ res.pop_back(); } } return res; } }; Go:\nfunc removeDuplicates(s string) string { var res []byte for i:=0;i\u0026lt;len(s);i++{ if len(res)\u0026gt;0\u0026amp;\u0026amp;res[len(res)-1]==s[i]{ res = res[:len(res)-1] }else{ res = append(res,s[i]) } } return string(res) } 150. Evaluate Reverse Polish Notation 5.题目描述 You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\nEvaluate the expression. Return an integer that represents the value of the expression.\n所谓逆波兰表达式就是像序列[\u0026quot;2\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;+\u0026quot;,\u0026quot;3\u0026quot;,\u0026quot;*\u0026quot;]这样的表达式\n5.解题思路 非常简单，读数字就入栈，然后读到符号就取两个运算，再把结果入栈\n不过得注意，先出栈的是第二个操作数\n5.代码实现 Python:\nclass Solution: operatorMap = {'+':add,'-':sub,'*':mul,'/':lambda x, y: int(x / y)} def evalRPN(self, tokens: List[str]) -\u0026gt; int: eval_stack = [] for i in tokens: if i in \u0026quot;+-*/\u0026quot;: op2 = eval_stack.pop() op1 = eval_stack.pop() eval_stack.append(self.operatorMap[i](op1,op2)) else: eval_stack.append(int(i)) return eval_stack.pop() Cpp:\nclass Solution { public: int evalRPN(vector\u0026lt;string\u0026gt;\u0026amp; tokens) { stack\u0026lt;long long\u0026gt; evalStack; for(int i=0;i\u0026lt;tokens.size();++i){ if (tokens[i] == \u0026quot;+\u0026quot; || tokens[i] == \u0026quot;-\u0026quot; || tokens[i] == \u0026quot;*\u0026quot; || tokens[i] == \u0026quot;/\u0026quot;){ long long op2 = evalStack.top(); evalStack.pop(); long long op1 = evalStack.top(); evalStack.pop(); switch (tokens[i][0]){ case '+': evalStack.push(op1+op2); break; case '-': evalStack.push(op1-op2); break; case '*': evalStack.push(op1*op2); break; case '/': evalStack.push(op1/op2); break; } }else{ evalStack.push(stoll(tokens[i])); } } return evalStack.top(); } }; 239. Sliding Window Maximum 噢噢噢，第一道Hard\n6.题目描述 You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\n6.解题思路 朴素的想法就是在这个范围内一次次找……\nclass Solution: def maxSlidingWindow(self, nums: List[int], k: int) -\u0026gt; List[int]: res = [] for i in range(0,len(nums)-k+1): res.append(max(nums[i:i+k])) return res 不过这样肯定TLE了\n样例有长达50000的滑动窗口，是真的狠……\n那肯定是不会做的，所以看视频了\n这个滑动窗口扩大的过程，就像是一个队列，如果这个队列能够维护一个最大值，就方便了\n那怎么做呢？\n优先队列，堆……好吧只知道名字\n但是它们不行，因为会自动改顺序，不能pop出离开窗口的内容\n于是就需要单调队列\n在入队的时候，弹掉前面比它小的元素，这样最大值就一定在队首\n6.代码实现 Cpp：\nclass Solution { private: class MyQueue{ public: deque\u0026lt;int\u0026gt; que; void pop(int value){ // 查空比照数值 if(!que.empty()\u0026amp;\u0026amp;que.front()==value){ que.pop_front(); } } void push(int value){ // 从队尾开始排除小于value的值 while(!que.empty()\u0026amp;\u0026amp;que.back()\u0026lt;value){ que.pop_back(); } // 插入 que.push_back(value); } int front(){ return que.front(); } }; public: vector\u0026lt;int\u0026gt; maxSlidingWindow(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { MyQueue que; vector\u0026lt;int\u0026gt; res; for(int i=0;i\u0026lt;k;++i){ que.push(nums[i]); } res.push_back(que.front()); for(int i=k;i\u0026lt;nums.size();++i){ que.pop(nums[i-k]); que.push(nums[i]); res.push_back(que.front()); } return res; } }; 347. Top K Frequent Elements 7.题目描述 Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\n7.解题思路 很简单，我们可以先用哈希表统计频率，然后再对哈希表按value进行排序……\nclass Solution: def topKFrequent(self, nums: List[int], k: int) -\u0026gt; List[int]: count_map = {} for i in nums: if count_map.get(i): count_map[i]+=1 else: count_map[i]=1 sorted_map = sorted(count_map.items(), key = lambda kv:kv[1],reverse = True) return [x[0] for x in sorted_map[:k]] 是不是少了些什么……如果不用Python呢？\n我们可以用优先队列解决这个问题\n优先队列，就是一个堆\n那么，什么是堆呢？\n堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。\n如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。\n对堆push时，会弹出头节点，因此使用大顶堆，每次都会弹出最大的元素\n使用小顶堆，每次排出最小的元素即可，这样留下的就是最大的K个元素\n这样，也比进行排序效率高，我们只需要维护k个有序序列就好\n7.代码实现 Cpp:\nclass Solution { public: class myCompare{ public: bool operator()(const pair\u0026lt;int,int\u0026gt;\u0026amp; lhs, const pair\u0026lt;int,int\u0026gt;\u0026amp; rhs){ return lhs.second\u0026gt;rhs.second; } }; vector\u0026lt;int\u0026gt; topKFrequent(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { // 哈希表统计元素频率 unordered_map\u0026lt;int,int\u0026gt; map; for(int i=0;i\u0026lt;nums.size();++i){ map[nums[i]]++; } priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;,vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;,myCompare\u0026gt; pri_que; // 扫描 for(unordered_map\u0026lt;int,int\u0026gt;::iterator it = map.begin();it!=map.end();it++){ pri_que.push(*it); // 用k大小的小顶堆扫描 if(pri_que.size()\u0026gt;k){ // 大于k就弹出最小值 pri_que.pop(); } } // 倒序输出 vector\u0026lt;int\u0026gt; res(k); for (int i=k-1;i\u0026gt;=0;i--){ res[i]=pri_que.top().first; pri_que.pop(); } return res; } }; 结束了，撒花花~\n","date":"2023-01-23","permalink":"https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A3%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","tags":["力扣"],"title":"力扣栈与队列"},{"content":"SICP Python版的笔记，读起来应该很快……吧？\n读了一点点后：快个鬼！\n1.1 引言 学习解释错误和诊断非预期错误的原因叫做调试（debugging）。它的一些指导原则是：\n逐步测试：每个写好的程序都由小型的组件模块组成，这些组件可以独立测试。尽快测试你写好的任何东西来及早捕获错误，并且从你的组件中获得自信。 隔离错误：复杂程序的输出、表达式、或语句中的错误，通常可以归于特定的组件模块。当尝试诊断问题时，在你能够尝试修正错误之前，一定要将它跟踪到最小的代码片段。 检查假设：解释器将你的指令执行为文字 \u0026ndash; 不多也不少。当一些代码不匹配程序员所相信的（或所假设的）行为，它们的输出就会是非预期的。了解你的假设，之后专注于验证你的假设是否整理来调试。 询问他人：你并不是一个人！如果你不理解某个错误信息，可以询问朋友、导师或者搜索引擎。如果你隔离了一个错误，但是不知道如何改正，可以让其它人来看一看。在小组问题解决中，会分享一大堆有价值的编程知识。 1.2 编程元素 最重要的复合表达式就是调用表达式，它在一些参数上调用函数。\n编程语言的要素之一是它提供的手段，用于使用名称来引用计算对象。如果一个值被给予了名称，我们就说这个名称绑定到了值上面。\n赋值是 Python 中的最简单的抽象手段，因为它使我们可以使用最简单的名称来引用复合操作的结果，这样，复杂的程序可以由复杂性递增的计算对象一步一步构建。\n将名称绑定到值上，以及随后通过名称来检索这些值的可能，意味着解释器必须维护某种内存来跟踪这些名称和值的绑定。这些内存叫做环境。\n求值过程本质上是递归的，也就是说，它会调用其自身作为步骤之一。\n数字求值为它标明的数值 名称求值为当前环境中这个名称所关联的值 纯函数：具有一些输入（参数）以及返回一些输出（调用结果）的函数。\n如内建函数abs。纯函数具有一个特性，调用它们时除了返回一个值之外没有其它效果。\n非纯函数：除了返回一个值之外，调用非纯函数会产生副作用，这会改变解释器或计算机的一些状态。一个普遍的副作用就是在返回值之外生成额外的输出\n例如print，其返回值为None。而Python的交互式解释器，并不会将其打印出来。现在考虑嵌套调用：\nprint(print(1), print(2)) 这时我们就不难发现它的非纯特性：\n\u0026gt;\u0026gt;\u0026gt; print(print(1), print(2)) 1 2 None None 签名：不同函数具有不同的允许接受的参数数量。\n为了跟踪这些必备条件，我们需要以一种展示函数名称和参数名称的方式，画出每个函数。abs函数值接受一个叫作number的参数，向它提供更多或更少的参数会产生错误。\nprint函数可以接受任意数量的参数，所以它渲染为print(\u0026hellip;)。\n函数的可接受参数的描述叫做函数的签名。\n1.3 定义新的函数 1.3.1 环境 如果形式参数和内建函数具有相同名称会如何呢？两个函数是否能共享名称而不会产生混乱呢？为了解决这些疑问，我们必须详细描述环境。\n表达式求值所在的环境由帧的序列组成，它们可以表述为一些盒子。每一帧都包含了一些绑定，它们将名称和对应的值关联起来。\n// 这么突兀就抛出一个帧，不好吧……看看英文版，嗯，翻得有点复杂\n我的理解：帧是当前编程环境的一个状态，存储名称和对应的值。\n在图中不难发现，对于函数abs而言，帧中有它的名字abs，而名字绑定的内容中同样有名字abs\n这种重复是有意的，许多不同的名字可能会引用相同函数，但是函数本身只有一个内在名称。\n当然，这种内在名称不会影响名字在环境中的检索。\nAs we proceed to introduce additional features of Python, we will have to extend these diagrams. Every time we do, we will list the new features that our diagrams can express.\nNew environment Features: Assignment and user-defined function definition.\n1.3.2 调用用户定义的函数 // 第一句话看了半天才明白……\n在调用用户定义函数时，Python解释器的行为类似于调用自建函数的过程\n即，类似于下图那样\n求出操作数表达式，再对实参调用具名函数（named fuction）\n这个行为便引入了相对于全局帧的一个局部帧，它只能由该函数来访问。\n为了在实参上实现这个用户定义函数：\n// 等等，到底什么是实现？\n将实参与形参绑定 // 注意，绑定是前面提到的术语 在局部帧的开头和全局帧的结尾求解（evaluated）函数体 // 第二点是什么意思呢？我现在没搞明白 // 不过，这里的求解是贯穿之前文本的evaluated，与之前SICP把函数调用和运算都看作表达式，是一致的\n这张图的解释在原文有就不复制了\n针对调用表达式square(-2)，我们有：\n这个调用表达式不在任何函数中，也就是说，它将在全局帧求值，会检索任何在全局帧中的名字 在square函数体内，它的返回表达式在自己的这个局部帧内求值，它将square的形式参数x的名称绑定到实参的值-2上 // 原文：它的返回表达式在上面的步骤1引入的新环境中求值 步骤一引入的新环境是什么？应该就是函数的局部帧吧？\n// 表达式求值所在的环境由帧的序列组成，那么是从全局帧进入到了局部帧，也就是在局部帧的开头和全局帧的结尾……吗？\n所以，环境中帧的顺序会影响表达式中名称检索返回的值\n// 说人话就是变量会在运行中发生变化\n所以，之前说名称求解（name evaluate，1.2.5出现的概念）为当前环境中与这个名称关联的值\n现在，就需要更进一步：\n名称求解为当前环境中，最先发现该名称的帧中，绑定到这个名称的值。\n// 啊啊啊，前面evaluate是求出，这里又是求解，不过毕竟是民间汉化，没办法 // 这种严丝合缝的书，感觉需要跳转功能的笔记\n天呐……我低估了这本书，可能得搁置一下了……\n","date":"2023-01-11","permalink":"https://shudorcl.github.io/post/sicp%E7%AC%94%E8%AE%B0/","tags":["笔记","计算机"],"title":"SICP笔记"},{"content":"速度变快了，是好事呢\n344. Reverse String 题目描述 Write a function that reverses a string. The input string is given as an array of characters s.\nYou must do this by modifying the input array in-place with O(1) extra memory.\n解题思路 这也是字符串？比反转链表简单多了……\nfunc reverseString(s []byte) { for i:=0;i\u0026lt;len(s)/2;i++{ temp:=s[i] s[i]=s[len(s)-1-i] s[len(s)-1-i]=temp } } 没必要使用temp\nfunc reverseString(s []byte) { for i:=0;i\u0026lt;len(s)/2;i++{ s[i],s[len(s)-1-i]=s[len(s)-1-i],s[i] } } 思考要求低的话可以用双指针……\nfunc reverseString(s []byte) { left,right:=0,len(s)-1 for left\u0026lt;right{ s[left],s[right]=s[right],s[left] left++ right-- } } 那就过了\n541. Reverse String II 又来啊？\n题目描述 Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.\nIf there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original.\n这题目写的什么？总之就是每2k个字符反转前面k个，剩余不足k全部反转\n解题思路 嗯，感觉无从下手，主要是不知道go的字符串是怎么处理的\n让我看看解析……\nfunc reverseStr(s string, k int) string { byteString := []byte(s) for key:=0;key\u0026lt;len(byteString);key+=2*k{ if key+k\u0026lt;=len(byteString){ reverse(byteString[key:key+k]) }else{ reverse(byteString[key:len(byteString)]) } } return string(byteString) } func reverse(s []byte){ left,right:=0,len(s)-1 for left\u0026lt;right{ s[left],s[right]=s[right],s[left] left++ right-- } } 感觉没什么自己的思考，这样不好\n剑指Offer 05.替换空格 题目描述 请实现一个函数，把字符串 s 中的每个空格替换成\u0026quot;%20\u0026quot;。\n解题思路 嗯哼，python3直接replace\nclass Solution: def replaceSpace(self, s: str) -\u0026gt; str: return s.replace(\u0026quot; \u0026quot;,\u0026quot;%20\u0026quot;) 那么go呢？\nfunc replaceSpace(s string) string { byteString := []byte(s) ans := make([]byte,0) for _,v := range byteString{ if v==' '{ ans=append(ans,[]byte(\u0026quot;%20\u0026quot;)...) }else{ ans=append(ans,v) } } return string(ans) } go在处理字符串的时候需要转换成[]byte\n而且，在append的时候，\u0026quot;%20\u0026quot;需要写成[]byte(\u0026quot;%20\u0026quot;)...，同样值得注意的是append一个slice时，需要在后面加上...\n为什么呢？先不管了\n那么，还有什么不占额外空间的解法吗？\n看了看思路，可以先将原数组扩充到空格全部替换为%20的长度\n然后，从后往前地，用双指针法替换空格，从前往后的话，需要移动数据，增加复杂度\n其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作\nfunc replaceSpace(s string) string { byteString := []byte(s) pointer := len(byteString)-1 spaceCount:=0 // 统计空格数 for _,v:=range byteString{ if v==' '{ spaceCount++ } } // 扩充长度 byteString=append(byteString,make([]byte,2*spaceCount)...) prePointer := len(byteString)-1 for ;pointer\u0026gt;=0;pointer--{ // 见空格替换退3 if byteString[pointer]==' '{ byteString[prePointer]='0' byteString[prePointer-1]='2' byteString[prePointer-2]='%' prePointer-=3 // 否则退1替换 }else{ byteString[prePointer]=byteString[pointer] prePointer-- } } return string(byteString) } 超过百分百，爆杀！\n151. Reverse Words in a String 题目描述 Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\n解题思路 python一行\nclass Solution: def reverseWords(self, s: str) -\u0026gt; str: return \u0026quot; \u0026quot;.join([x for x in s.split(\u0026quot; \u0026quot;)[::-1] if x!=\u0026quot;\u0026quot;]) 那么，go呢？\n想了想，感觉可以倒着读，遇到空格就反转塞进去\nfunc reverseWords(s string) string { byteString := []byte(s) pointer := len(s)-1 headPointer := 0 //去除尾部空格 for byteString[pointer]==' '{ pointer-- } pointer++ //去除头部空格 for byteString[headPointer]==' '{ headPointer++ } ans:=[]byte(\u0026quot;\u0026quot;) prePointer:=pointer-1 for ;prePointer\u0026gt;headPointer;prePointer--{ if byteString[prePointer]==' '{ ans=append(ans,byteString[prePointer+1:pointer]...) ans=append(ans,[]byte(\u0026quot; \u0026quot;)...) pointer=prePointer } } ans=append(ans,byteString[prePointer:pointer]...) return string(ans) } 啊，中间也不能有连续的空格？\nfunc reverseWords(s string) string { byteString := []byte(s) pointer := len(s)-1 headPointer := 0 //去除尾部空格 for byteString[pointer]==' '{ pointer-- } pointer++ //去除头部空格 for byteString[headPointer]==' '{ headPointer++ } flag:=true ans:=[]byte(\u0026quot;\u0026quot;) prePointer:=pointer-1 for ;prePointer\u0026gt;headPointer;prePointer--{ if flag\u0026amp;\u0026amp;byteString[prePointer]==' '{ ans=append(ans,byteString[prePointer+1:pointer]...) ans=append(ans,[]byte(\u0026quot; \u0026quot;)...) pointer=prePointer flag=false } if !flag\u0026amp;\u0026amp;byteString[prePointer]!=' '{ pointer=prePointer+1 flag=true } } ans=append(ans,byteString[prePointer:pointer]...) return string(ans) } 但是卡了四个用例……比如\u0026quot;I ueG7yY0Tgo i8Q9SUKyLz vk4zC 9p eDpBX96MRL IhzW K T 6FzR0 yKYgG\u0026quot;\n很好……这样就行了\nfunc reverseWords(s string) string { byteString := []byte(s) pointer := len(s)-1 headPointer := 0 //去除尾部空格 for byteString[pointer]==' '{ pointer-- } pointer++ //去除头部空格 for byteString[headPointer]==' '{ headPointer++ } flag:=true ans:=[]byte(\u0026quot;\u0026quot;) prePointer:=pointer-1 for ;;prePointer--{ if flag\u0026amp;\u0026amp;byteString[prePointer]==' '{ ans=append(ans,byteString[prePointer+1:pointer]...) ans=append(ans,[]byte(\u0026quot; \u0026quot;)...) pointer=prePointer flag=false } if !flag\u0026amp;\u0026amp;byteString[prePointer]!=' '{ pointer=prePointer+1 flag=true } if prePointer==headPointer{ break } } ans=append(ans,byteString[prePointer:pointer]...) return string(ans) } 看看题解有什么解法\n嗯哼，还能不用辅助空间？\n反转整个字符串，然后再反转单词？还能这样\n首先，我们先关注如何去掉空格，我自己的解法里面是只去除了首尾，但是实际上可以读一次全部去除\n这里就类似于数组中的移动元素，用双指针来标定移动后数组的长度，然后切一下片\n然后，再遍历反转后的字符串，反转里面的单词，这里就和原来很像了\nfunc reverseWords(s string) string { slowKey, fastKey:=0,0 byteString := []byte(s) // 去除头部空格 for fastKey\u0026lt;len(byteString)\u0026amp;\u0026amp;byteString[fastKey]==' '{ fastKey++ } // 过滤中间空格，slowKey即为去除后的切片长度 for ;fastKey\u0026lt;len(byteString);fastKey++{ value:=byteString[fastKey] if fastKey\u0026gt;1\u0026amp;\u0026amp;value==' '\u0026amp;\u0026amp;value==byteString[fastKey-1]{ continue } byteString[slowKey]=value slowKey++ } // 去除末尾空格 if slowKey\u0026gt;1\u0026amp;\u0026amp;byteString[slowKey-1]==' '{ byteString=byteString[:slowKey-1] }else{ byteString=byteString[:slowKey] } // 反转整个字符串 reverse(\u0026amp;byteString, 0, len(byteString)-1) // 反转单词 slowKey = 0 for slowKey \u0026lt; len(byteString) { fastKey = slowKey for fastKey \u0026lt; len(byteString) \u0026amp;\u0026amp; byteString[fastKey] != ' '{ fastKey++ } reverse(\u0026amp;byteString, slowKey, fastKey-1) slowKey = fastKey slowKey++ } return string(byteString) } func reverse(b *[]byte, left, right int) { for left \u0026lt; right { (*b)[left], (*b)[right] = (*b)[right], (*b)[left] left++ right-- } } 剑指 Offer 58 - II. 左旋转字符串 LCOF 题目描述 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\u0026quot;abcdefg\u0026quot;和数字2，该函数将返回左旋转两位得到的结果\u0026quot;cdefgab\u0026quot;。\n解题思路 在有切片的语言里面是非常简单的\nfunc reverseLeftWords(s string, n int) string { byteString := []byte(s) byteString = append(byteString,byteString[:n]...) return string(byteString[n:]) } 那么，有什么不扩展空间的解法吗？\n……想不出来，看看题解\n居然也是反转\nfunc reverseLeftWords(s string, n int) string { byteString := []byte(s) // 先反转前n个字符 reverse(byteString,0,n-1) // 然后反转后n个字符 reverse(byteString,n,len(byteString)-1) // 最后反转整个字符串 reverse(byteString,0,len(byteString)-1) return string(byteString) } func reverse(byteString []byte, left int, right int){ for left\u0026lt;right{ byteString[left],byteString[right]=byteString[right],byteString[left] left++ right-- } } 局部反转再整体反转……吗\n28. Find the Index of the First Occurrence in a String 题目描述 Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nKMP算法？如果用语言的库函数的话又太简单了\n解题思路 库函数解法\nfunc strStr(haystack string, needle string) int { return strings.Index(haystack,needle) } 有点没意思\n那么不用库函数的话，就得自己实现字符串匹配算法，那就得再看数据结构了\n先摸了！\nKMP笔记 KMP思想：利用已经匹配的信息\n前缀表：获得该串对应的位置的最大相同前后缀长度\n暴力解法：匹配失败后，从断点处，将模式串从头开始匹配\nKMP：匹配失败后，因为有前缀表，可以根据前缀表，找到该位置最大相同前后缀，\n也就是说，这一部分是相同的，是可以继续接上进行匹配的\n比如，考虑aabaabaafa中查找aabaaf，会在下标为5的位置失去匹配，但是此时，在模式串中，字串[:5]拥有长度为2的最大相同前后缀，所以，模式串将会在[2]b这个位置开始继续匹配，而非从头开始\n从而，模式串从前缀表指示的位置重新开始，与文本串在断点处开始匹配\n这样，匹配的复杂度就进一步降低了，为O(n*m)\n不过，我们还得深入到更多细节\n代码实现 看不懂，要睡觉了\n起来了，不想看文字了，看视频！\n构造next数组 初始化 处理前后缀不相同的情况 处理前后缀相同的情况 相同就跟着走，不相同j就回退到相同\nvoid getNext(int* next, const string\u0026amp; s){ int j = -1; next[0] = j; for(int i = 1; i \u0026lt; s.size(); i++) { // 注意i从1开始 while (j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退 } if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++; } next[i] = j; // 将j（前缀的长度）赋给next[i] } } 利用next数组做匹配 int j = -1; // 因为next数组里记录的起始位置为-1 for (int i = 0; i \u0026lt; s.size(); i++) { // 注意i就从0开始 while(j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != t[j + 1]) { // 不匹配 j = next[j]; // j 寻找之前匹配的位置 } if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动 j++; // i的增加在for循环里 } if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t return (i - t.size() + 1); } } 一样地，相同跟着走，不一样就按照next数组回退\n统一实现 class Solution { public: void getNext(int* next,const string \u0026amp;s){ int j = -1; next[0] = j; for(int i=1;i\u0026lt;s.size();++i){ while(j\u0026gt;=0\u0026amp;\u0026amp;s[i]!=s[j]+1) j =next[j]; if(s[i]==s[j+1]) j++; next[i]=j; } } int strStr(string haystack, string needle) { if(needle.size()==0) return 0; int next[needle.size()]; getNext(next,needle); int j=-1; for(int i=0;i\u0026lt;haystack.size();++i){ while(j\u0026gt;=0\u0026amp;\u0026amp;haystack[i]!=needle[j+1]) j=next[j]; if(haystack[i]==needle[j+1]) j++; if(j==(needle.size()-1)) return i-needle.size()+1; } return -1; } }; 怎么没全过……\n对比了一下标答没什么区别，为什么他就可以过呢？\n啊啊啊，不管了，下一题，下一题！\n459. Repeated Substring Pattern 题目描述 Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.\n解题思路 一看，除了暴力一个个匹配以外都不知道\n看看评论区，《简单》\n好，投了，看题解\n移动匹配 原来如此，把两个原字符串s拼在一起，然后掐头去尾找还有没有原串s就行了……\nclass Solution { public: bool repeatedSubstringPattern(string s) { string t = s+s; t.erase(t.begin()); t.erase(t.end() - 1); if (t.find(s) != std::string::npos) return true; return false; } }; 枚举 class Solution { public: bool repeatedSubstringPattern(string s) { int n = s.size(); for (int i = 1; i * 2 \u0026lt;= n; ++i) { // 比较到n/2即可 if (n % i == 0) { // 可以整除可以由数个字串组成 bool match = true; for (int j = i; j \u0026lt; n; ++j) { if (s[j] != s[j - i]) { // 从长度1开始，一个个从0开始比较 match = false; break; } } if (match) { return true; } } } return false; } }; KMP 什么，这也能KMP？\n首先，我们得知道KMP的精髓是什么，是利用前缀表得到最大 相同 前后缀 的长度\n前后缀……？\n正是因为 最长相等前后缀的规则，当一个字符串由重复子串组成的，最长相等前后缀不包含的子串就是最小重复子串。\n这段推理我没看太懂，摸了\n好，看懂了\n也就是说，我们可以得到t[0]=k[0]=t[2]=s[2]，这样推导下去就是我们需要的重复子串\n最大前后缀的公共部分之外的长度，如果可以整除字符串长度，就说明这个字符串满足条件\nclass Solution { public: // 求前缀表 void getNext (int* next, const string\u0026amp; s){ next[0] = -1; int j = -1; for(int i = 1;i \u0026lt; s.size(); i++){ while(j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j + 1]) { j = next[j]; } if(s[i] == s[j + 1]) { j++; } next[i] = j; } } bool repeatedSubstringPattern (string s) { if (s.size() == 0) { return false; } int next[s.size()]; getNext(next, s); int len = s.size(); // 如果可以整除则满足 if (next[len - 1] != -1 \u0026amp;\u0026amp; len % (len - (next[len - 1] + 1)) == 0) { return true; } return false; } }; 一个多月了终于做了十道题，不知道说什么好……\n","date":"2022-12-06","permalink":"https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A3%E5%AD%97%E7%AC%A6%E4%B8%B2/","tags":["力扣"],"title":"力扣字符串"},{"content":"读各种闲书做的复制粘贴与吐槽\n刘擎西方现代思想讲义 三手甚至二手现代性思想，梗指南ProPlus，正适合我这种读不下原典又想了解些皮毛的庸俗之人\n第二章 现代人的精神危机 弗洛伊德II 人生意义的两大难题就是面对死亡和欲望。如何超越欲望的卑微，走向人性的崇高，这是现代精神危机中的一个重要问题。而弗洛伊德的影响不是解决了这个问题，而是取消了这个问题：如果我们接受了欲望的正当性，欲望本身不再是卑微可耻的，也就用不着去超越欲望了\n// 天理即人欲，王阳明又来了……\n萨特II 萨特还用一对概念来区分物的存在和人的存在，物的那种被决定的、不能改变的存在，叫作“自在”的存在。人的这种“有待形成”的、不固定的存在，叫作“自为”的存在，就是自己“为自己”而存在。你可以记住这一点：自在的存在有一个固定不变的本质；而自为的存在没有固定的本质，它的本质是可以变化的。也就是存在即虚无，因此就同大自然厌恶真空一样，人有了自己永恒的追求\n人是自为的存在，不断为自己寻找本质，不断变化。换句话说，人有无限的潜在可能性。人想通过占有物去获得确定性，但有限的、固定不变的东西没有办法填满无限的可能性。人是一种徒劳的激情，去追求，去寻找，但终究无法实现那种满足。\n“生活中只有两种悲剧：一个是没有得到我们想要的，另外一个是得到了我们想要的”\n因为存在先于本质，那么就没有什么预先给定的东西把我们固定住、束缚住，就意味着我们永远可以超越“过去的本质”“现在的本质”去追求“未来”，人类掌握着命运的自主性。\n人永远不会“是”什么，而是永远都正在“成为”什么。在这个意义上，人是自由的，甚至人就是自由本身。也就是说，从存在即虚无，萨特推断出了人类被判定为自由！\n萨特说的自由不是为所欲为的自由，而是总是可以改变现状的自由，是否定只能如此、我别无选择的那种自由\n// “人类的赞歌就是勇气的赞歌；人类的伟大就是勇气的伟大。”似乎有异曲同工之妙\n但是，这种自由有着沉重的代价\n萨特III 可是自由的命运不是轻轻松松的好事，它还有非常严酷的一面。萨特两个著名的观点：第一，自由选择是很沉重的负担；第二，他人就是地狱。\n人类有着掌握命运的绝对自由，但是这份绝对自由意味着，只有你才能为自己的选择负责，其他的标准因素，只是因为你顺从了那个标准，归根结底，你还是要为你的选择负责，这就是从绝对的自由，又推导出了绝对的责任。\n“如果上帝死了，那么一切都被允许了。”\n《不能承受的生命之轻》，人的无限可能是轻盈而自由的，但正是这份自由带来的绝对的责任是不能承受的，你必须独自选择，独自承担\n那么，转求他人的帮助呢？\n萨特的思想中，人具有掌握自己命运的能力，即主体性，人都是自由的，那么人与人之间，就会有争夺主体性的过程。\n别人瞅你，就是维护自己的主体性并否定你的主体性将你物化，而你瞅回去，就是同样维护自己的主体性。\n由此推广，爱情也是一样，想象中的浪漫爱情是一个骗局，那种不分彼此、合二为一的爱情体验，只不过是刚刚开始时候的幻觉罢了。爱情同样充满了为争夺主体性而展开的冲突和斗争。到最后要么是受虐，在羞耻中享受快乐；要么是施虐，在内疚中感到愉悦。\n萨特认为憎恨其实就是你承认了别人的自由，憎恨只能指向人，正是因为他人的行动使你丧失了主体性，你为了维护主体性做出反击，实际上就是变相承认了他人的自由。\n所以，人与人之间只能有永恒的主体性的斗争，人只能，孤独的面对自己的选择\n所以，存在主义是一种绝望的哲学，滥觞于虚无，结末于孤独，中间还有沉重的责任。\n但，存在主义也是一种希望的哲学，我们永远有改变的潜能，不必服从任何注定的命运，所以存在主义更是一种行动的哲学。我们最根本的自由和可能性都在行动中实现，它们并不只属于尼采式的超人，而是根植于每个人的存在之中。\n西西弗斯是幸福的，因为登上顶峰的斗争足以充实人的心灵\n第三章 20世纪的教训 上一章是现代人的精神危机，这一章便是现代人公共生活的危机\n政治权威\n政治学的基本假设，资源匮乏和人性自利\n// 那么安纳其主义呢？不过我也不了解\n也就意味着，公共秩序无法自然形成，需要某种强制性的政治权威建立维护规则\n但政治权威不止有强制性，更有合法性，一开始自然封建秩序不需要考虑，但随着人将自己视为自由而平等的个体，必须有新的理论出现来维护政权，那就是社会契约论，它塑造现代政治的理性主义特征：将政治秩序视为理性建构的人造之物\n在20世纪上半叶，西方出现了三种相互竞争的主要政体形式：苏联的社会主义，西欧与北美的资本主义民主，以及德国的纳粹主义（民族社会主义），他们都具有突出的现代理性主义特征，但却都出现了困境和危机，便是20世纪的教训\n在血腥程度上而言，20世纪的灾难与之前中世纪的灾难没有什么不同，但是，1900年的时候，我们不是看到人类在各个方面都在发展和进步吗？难道这些发展和进步都被打断了吗？并不是这样。无论是自然科学还是社会科学，在20世纪都获得了比以往更加巨大的进步，这一百年中，人类总体的文明程度是大幅提升的。\n20世纪带给我们的将是科学进入社会和私人生活。科学将赋予我们行为的准则。它将是一种光辉灿烂的前景……我们希望哺育了我们的19世纪，把那愚蠢的仇恨、无意义的争斗和可笑的诽谤统统带走，抛进世纪的无底深渊！\n所以，20世纪的灾难是“文明时代”的野蛮，是“理性时代”的疯狂\n不是发展中因为运气太差出现的偶然，20世纪的危机不是历史的偶然产物，而是内在于现代化思想之中。德国的纳粹主义、苏联式的社会主义和英美的资本主义，是三种不同的现代性规划，它们都有各自的危机或困境，但都与现代理性主义的社会构想密切相关\n所以，需要剖析和反思，揭示行动背后的深层逻辑，揭示出一些思想观念是如何塑造了人类的行为。而这些论断，又成为人类行动新的思想依据。\n“不要轻视观念的影响力，教授在沉静的研究中所培育出来的哲学观念，可能会摧毁一个文明[……]如果思想能够产生如此致命的力量，那么也只有通过其他思想家的努力，才能来化解。”\n鲍曼 《现代性与大屠杀》\n大屠杀是现代性本身固有的一种潜在可能，它只有在现代文明中才可能实现\n纳粹的大屠杀是反人类的暴行，但是这件事却发生在已经步入现代文明两百多年的中世纪\n最方便的解释自然是，看作一次偶然的反常现象\n于是，就有了两种解释，变态论和仇恨论\n鲍曼认为这是站不住脚的，是在逃避最需要反思的深刻问题\n实际上，正是现代性内部的一些本质要素，才使得大屠杀成为现实。而其中关键的一点，就是理性和理性化。\n首先，正是机器般理性的现代官僚制，实现了大屠杀这个非理性的暴行\n官僚制不仅会损害个人自由，还会导致道德冷漠、逃避责任。现代官僚体系像一部庞大的机器，每个人都只是一个零件，在作为零件高效率运转的过程中，却丧失了对总体目标的责任感和道德感。\n大屠杀发生的场景如同一个工业流水线般，每个人只负责其中的一小部分，完成一个微小的步骤\n在这种流程中，人很容易丧失面对鲜活生命时的同情心和道德感。结果就是，每一个步骤组合起来共同造成了屠杀，而其中的操作者感受到的可能只是“我今天填了十张表”。这就是为什么那些在私人生活中正常甚至善良的人，也可能成为屠杀的实施者。\n其次，现代科学主义实际上对大屠杀提供了某种理念支持。社会秩序就是一项工程，可以在科学理性的指导下整理得干干净净，整齐划一，清晰优美。\n在这种观念中，犹太人变成了秩序里的“杂质”。\n此外，理性的影响同样体现在被害一方，当时不仅没有出现犹太人的大规模反抗，在大屠杀中甚至还有受害者的参与。\n鲍曼认为，这种合作是经由一种策略实现的，就是纳粹对受害者理性计算心理的利用。大屠杀不是一个公然宣布的清晰计划，否则肯定会立刻爆发大规模的抵抗。当时的犹太人并不知道这是一场种族灭绝，直到最后一刻，很多人都以为自己有可能活下来。纳粹利用了这种求生希望，消解了可能的反抗。\n只要考虑到人的理性计算心理，就可以在给受害者提供选项的时候，调整其中的收益，去引导受害者合作。\n因而，大屠杀不是历史上野蛮状态的重现，也不是一场偶然的悲剧。大屠杀的许多关键要素都内在地蕴藏于现代理性之中。这场灾难，是现代理性如何变得与道德和人性完全背道而驰的一个历史力证。\n在鲍曼看来，要防范像大屠杀这样的灾难，关键在于要坚守一种不可让步的、无条件的道德感，保持对他人的道德感知。简言之，就是永远别忘了你面前的人是一个人。\n不过，现代社会的底层机制中就存在着一种非个人化或者非人格化的特性。如何在这种特性中保持我们的道德感，这是现代人需要思考的严肃问题，也是现代社会要面对的一个艰巨的挑战。\n// 当代的国家治理，或多或少都有法团主义的因素在里面\n阿伦特I 大屠杀真的是平庸之恶吗？\n阿伦特创造了“平庸之恶”这个概念\n平庸之恶不是一种“螺丝钉理论”，就是说普通人只不过是某个官僚系统中的一个螺丝钉或齿轮，只是服从程序、执行命令，所以冷漠地成为杀人机器的一部分。可是阿伦特自己明确表示不赞同“螺丝钉理论”。\n平庸之恶也不是大众导致的恶，经常说“雪崩发生的时候，没有一片雪花是无辜的”，但阿伦特也不会赞同这种理解。因为如果你把责任推给所有人，泛泛地加以指责，那么就无法再追究任何特定个人的责任。阿伦特反对所谓“集体罪责”的观点，她主张应当追究个人的责任。\n阿伦特看来，大屠杀是是一种新颖而独特的现代罪恶\n在平庸之恶前，阿伦特曾用极端之恶（radical evil）来描述纳粹的大屠杀，十年之后，在纳粹军官艾希曼受审时，用平庸之恶（banality of evil），也就是恶的平庸性，来描述纳粹。\n也就是，阿伦特认为纳粹的大屠杀是一种极端之恶，在军官身上，她看到了恶的平庸性\n纳粹大屠杀是一种极端之恶，极端在哪里呢？不是死人的数量和手段的残忍，这些在历史上早有回响。这种极端不是程度上的，而是性质上的，因为纳粹大屠杀呈现出一种独特的、前所未有的特征，那就是它“完全不可理解”。\n康德有一句名言，“人是目的，而不仅仅是手段”。如果你把他人仅仅当作自己实现利益的手段，那就践踏了人的尊严，是不道德的。而纳粹大屠杀令人震惊的地方在于，纳粹不仅没有把犹太人看成是目的，甚至都没有把他们当作工具、当作手段。\n即便是杀人取乐，也有取乐的目的，但是纳粹的动机不是出于人性的自私、贪婪、恐惧、复仇欲望或者施虐欲望，纯粹就是把犹太人看作是多余的东西。这不仅仅是否定了人的尊严，而是连他们可利用的工具性的价值都否定了。\n在阿伦特看来，纳粹彻底否定了人类当中一部分人的生存价值，他们断定只有某些人才是人，否定了人类存在的多样性。等于“根除人这个概念本身”。\n所以，这种恶已经超出了康德的道德哲学框架，也无法从“人能理解的动机”来解释。所以它和任何传统的罪行不同，是一种完全新颖的现代现象。\n那么如何理解这种新颖的极端之恶呢？\n“细菌可以造成流行病的灾难，但细菌仍旧只是细菌”\n在艾希曼身上，阿伦特看到了恶的平庸性。\n艾希曼不是戏剧中那样复杂而深刻的反派，也不是残暴无情的恶魔，但他有“一种超乎寻常的浅薄”，“不是愚蠢，而是匪夷所思地、非常真实地丧失了思考能力”。这就是艾希曼身上的“平庸性”，实质上是一种“无思状态”（thoughtlessness），就是不思考。\n这就是平庸之恶的独特之处，我们在谈论道德的时候，要既论迹又论心，邪恶的人一定是有作恶的动机或者主观故意，犯下的恶行越严重，就说明他的意图越坏。但在阿伦特的分析中，我们看到了一种新型的罪恶，它不是从自身的邪恶动机出发的，而是因为放弃了思考、丧失了思考能力而作恶，是一种没有残暴动机的残暴罪行。\n应当注意，不能滥用平庸之恶这种说法，它只适用于极端之恶的作恶者，而非生活中那些普通的不道德行为。\n那么，似乎克服平庸之恶的方法，就是无论在什么情况下，我们都应当保持自己的思考能力。\n但是，正常人都会思考，为什么阿伦特认为他们丧失了思考能力？\n这不是答案，只是一个新问题的开始\n阿伦特II 阿伦特认为“平庸之恶”是丧失思考能力的结果\n人怎么就丧失了思考能力？丧失的是哪种思考能力？\n阿伦特计划写作《精神生活三部曲》，最后一部只有标题：Judging 判断\n艾希曼在法庭山侃侃而谈，认为自己是履行职责，遵守法律\n阿伦特并不是说他愚蠢或者撒谎，而是因为他满口套话，将陈词滥调作为盾牌和武器抵挡现实\n他虽然引用康德，但是在阿伦特看来，这种引用令人发指且不可理喻，因为康德所讲的道德，恰恰与独立判断密不可分\n在现代社会，只是服从主流规则已经不能再防止人们作恶\n在第三帝国，人们陷入了一种困境当中，遵纪守法可能迫使你去犯罪作恶，而行善可能要求你违抗法律和规则。\n针对这种困境，阿伦特主张，传统的道德法则和教化已经不能促成真正的道德思考。道德的真正含义不是循规蹈矩，而是做出自己独立的是非对错的判断。\n但是，独立判断时一种在理论上和实践上都相当困难的要求\n独立不等于正确。要独立判断，就得抛弃对既定规则的服从，自己确立自己的标准。而且，现代性的根本困境之一是它瓦解了传统的价值规范，却无法建立起新的普遍有效的价值标准。因此，盲从是危险的，但独立判断也无法担保正确，还要面临巨大的风险。\n道德思考没有通则可循，独立的道德判断就是艰巨的任务。\n独立判断就成为了责任风险极大的事情\n如果循规蹈矩，那么，你就可以隐藏在人群中，用法不责众来分担错误的风险\n如果坚持独立判断，那么，你就是面目清晰的个体，你无法将判断的责任推诿给众人，也无法诉诸通用法则；因此你的责任是可辨识的，也是可追究的。你没有任何托词，没办法推给规矩，也没办法躲到“法不责众”的后面，你必须为自己承担全部责任。\n更难的问题是：我们应该如何做到独立判断？\n阿伦特自己也没有给出完整的解决方案\n阿伦特认为，施密特和卢卡斯这样的人始终要求“忠实于自己”，他们做出独立判断的前提是始终保持“与自己相处、与自己交谈的倾向”。他们选择不作恶，不是为了服从于纳粹之外的某个戒律，而是因为他们无法接受作为杀人犯的自己，他们不愿意与这样一个自己共存。为此，他们甘愿承受危险、甚至付出生命。\n这种独立判断的典范在西方思想的源头中就存在，那就是苏格拉底。苏格拉底说过“宁可自己遭受冤屈，也不愿行不义”，这样他至少能够与自己和睦相处。达到这样的境界并不要求有多么高深的知识，多么聪明的头脑，只是要求你始终过一种自我反思的生活，不断与自己的内心对话。\n这就是道德正直，moral integrity\n这样的人能够坦然面对自己，不用规矩和套话来自我欺骗，保全了自己人格的完整\n独立判断究竟要怎么做？阿伦特曾经说，“就各种特殊情况做出判断而言，没有什么恒常的通行标准，也不存在什么确定无疑的规则”。我们只能在具体的处境中，冒着风险，真诚地去做出自己独立的判断，并为此承担责任。这是现代社会的公民格外艰巨的道德任务\n波普尔I 科学是怎么被重新定义的？\n理性已经无法面对价值和道德的问题，那么，在科学活动中，理性就没有极限吗？\n人类是容易犯错的物种，这是人类固有的特征。不管是在科学还是在政治经济活动中，我们都摆脱不了“可错性”（fallibility）\n证伪主义理论\n科学理论的标志不是它能够被证明是对的，而是它可以被证明为错的。\n所以说，科学中的“正确”应该是什么？\n波普尔认为：科学中的正确永远是一种不彻底的正确。\n一个理论算不算科学理论，首先不是看它的对错，而是要看它是否能够接受事实的检测，是否可能被证伪。波普尔认为，这才是区别科学与非科学理论的试金石，他把这叫作“可证伪性”。\n在这个意义上，一个科学理论就不会是“彻底正确”的，因为它自身就包含着被证伪的可能。\n但是，波普尔所言的不彻底的正确，还有更深层的含义。\n他意识到证实和证伪是不对称的。一个理论被证实一百次、一千次、一万次，也不能证明它绝对正确，但只要被证伪了一次，它就被推翻了。\n这就对科学传统的归纳法，发起了挑战。\n// 想想三体I中那几个例子，大刘应该也看过这方面的论述\n那么，如果归纳法不可靠，那么，如何解释科学的成长机制呢？\n波普尔说，传统观点认为，科学发现是靠归纳，就是观察事实-归纳理论-证实理论。\n其实并非如此，科学发现的逻辑应该是这样：先提出问题，然后针对问题提出理论猜想，再用事实证据来检测这个猜想。如果检测和猜想相符，就保留这个猜想。\n如果一直没有反面的证据，就一直维持这个猜想的暂时有效性。如果出现了反面的证据，我们就放弃这个猜想，构想新的理论，进入下一轮检测。科学发展就是一个猜想与反驳的不断试错的过程。\n这样，波普尔就重新定义了科学发展的逻辑，用经验检测的“可证伪性”代替“可证实性”，用“问题—猜想—反驳”的“试错机制”代替“观察—归纳—证实”的“实证机制”，这就对科学发展提出了新的解释。\n这也意味着，科学无法达到绝对真理，科学永远只能获得暂时的正确性，这就是“不彻底的正确”\n就这样，科学理论不再是真理，而只是一些尚未证伪的假设\n在波普尔看来，科学是一种特定的认知方式，但并不是启蒙传统以为的那样，能够在思想领域一统天下。\n有些思想传统虽然不是科学，但本身有丰富的意义和价值，有些还可以成为科学猜想的灵感来源。比如宗教、神话和形而上学，包括精神分析，都属于这一类。\n波普尔II 为什么人类不能创造出完美社会？\n即使是在科学的领域，理性所能达到的“正确”也只是一种“不彻底的正确”。\n当波普尔把这个思考延伸到社会政治领域，就形成了他更为基本的哲学思想，叫作“批判理性主义”\n也就是，人类有理性，理性有局限\n理性使人类找到解决问题的方法，局限体现在，人类的办法总是不完美的，总会出现新的问题。\n所以，人类在进步中犯错，在犯错中学习，从此又继续进步，但即便如此\n也永远无法抵达绝对的真理\n在科学领域，波普尔拒绝了科学至上论，在社会领域，批判理性主义要拒绝的，便是乌托邦社会工程的理念\n什么是乌托邦社会工程呢？\n简单来说，就是认为人类可以依靠自己的理性，按照某种预定的蓝图去改造整个世界，创造出完美的社会。波普尔认为，将这种社会工程的理念付诸实践，往往会导致灾难性的后果。\n当然，不是指一般的规划，而是范围极广，时间极长的，一步迈向乌托邦的，终极的规划\n也就是整体主义社会工程，它低估了这种规划的可错性\n这背后有一种迷人的观念，就是历史决定论\n其认为历史是被一套规律所决定的，人的主观能动性只能发挥很小的一部分作用\n这样，社会科学的使命，就变成了找到这个规律，并预测历史，从而制定最完美的社会蓝图来改造社会\n波普尔在《历史决定论的贫困》中认为，人类并不能发现历史发展的铁律，自然科学尚且无法发现，更为复杂的人类社会，那就更难发现所谓的铁律了。\n其次，人类的知识本身就会影响历史的发展，因此历史本身无法被决定，也无法被科学方法预测。\n比如，马克思将理论公布于世，虽然工人阶级学会了他的思想，但是资本家同样也能学习到这属于全人类的知识\n于是，他们意识到了改良资本主义的迫切性和必要性，这样缓解了劳资矛盾，减慢了资本主义灭亡的进程\n在《开放社会及其敌人》中，波普尔认为信奉历史决定论，会在思想上封闭社会发展的可能性，塑造一个封闭社会的意识形态。\n与之对应的便是开放社会，以开放的态度接受理性的批判\n开放社会同样需要社会工程，但不是这样整体主义的构成，而是波普尔自己倡导的“零星社会工程”，做出温和的改良，以防止激进的革命，通过不断纠错来实现社会发展\n这两者之间有三个重要的区别：\n第一，前者着眼于克服最紧迫的恶，而后者是要追求最终极的善。\n第二，前者要寻求改善人们命运的合理方法，而后者也许有着极其善良崇高的意愿，但在实践中却可能加重了现实的苦难。\n第三，从历史上看，渐进式的改良基本上能够成功，而试图整体性地创造乌托邦的规划，基本上都会引发悲剧，最终背离了自己当初的蓝图目标。\n“缔造人间天堂的企图，结果总是造就了人间地狱”\n所以，他认为20世纪留下的最深刻的教训之一便是，警惕历史决定论的神话，防范“乌托邦社会工程”的实践。\n// 罗圣有言：“不要妄想在地上建设天国”\n你怎么理解“理性的局限性”呢？像这样的说法，“现在还有很多科学解释不了的事情，所以不用太在意科学给出的解释”，它和波普尔所说的“理性的局限性”是一个意思吗，你是怎么看待的呢？\n不准确，理性的局限性是说明人类无法获得绝对的真理，是反对把科学奉为圭臬，而非否定现存的科学理论\n","date":"2022-12-05","permalink":"https://shudorcl.github.io/post/%E8%AF%BB%E4%B9%A6%E6%9C%AD%E8%AE%B0/","tags":["杂物"],"title":"读书札记"},{"content":"哈希表怎么用倒是没那么难……\n一般哈希表都是用来快速判断一个元素是否出现集合里\n242. Valid Anagram 题目描述 Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n解题思路 排序字符串 最简单的，排序字符串\nclass Solution: def isAnagram(self, s: str, t: str) -\u0026gt; bool: return \u0026quot;\u0026quot;.join(sorted(s))==\u0026quot;\u0026quot;.join(sorted(t)) 但这毕竟不是哈希表……\n哈希表 func isAnagram(s string, t string) bool { exist:=[26]int{} for _,v:=range s{ exist[v-rune('a')]++ } for _,v:=range t{ exist[v-rune('a')]-- } for i:=0;i\u0026lt;len(exist);i++{ if exist[i]!=0{ return false } } return true } 之前写得比较复杂，思路是读两个字符串再对比，这样更简洁一些\n以及Go遍历字符串的话需要注意，range遍历是rune类型，而下标遍历是byte类型\n349. Intersection of Two Arrays 题目描述 Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.\n解题思路 没什么好说的，读nums1入哈希然后一个个比对nums2就好\nfunc intersection(nums1 []int, nums2 []int) []int { ans := []int{} uniqueMap:=make(map[int]bool) for _,v := range nums1{ uniqueMap[v]=true } for _,v := range nums2{ if key,ok:=uniqueMap[v];key\u0026amp;\u0026amp;ok{ ans = append(ans,v) uniqueMap[v] = false // 标false以免重复加入ans } } return ans } 202. Happy Number 题目描述 Write an algorithm to determine if a number n is happy.\nA happy number is a number defined by the following process:\nStarting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy. Return true if n is a happy number, and false if not.\n解题思路 这……这和哈希表有什么关系吗！\n看了看题解，因为求快乐数的过程是不是无限循环就是结果为1，所以用哈希表可以快速判断一个元素是否出现集合里（照应前文了，鼓掌👏👏👏）\nfunc isHappy(n int) bool { existMap := make(map[int]bool,10) for n!=1\u0026amp;\u0026amp;!existMap[n]{ n,existMap[n] = getSum(n),true } return n==1 } func getSum(n int) int{ sum:=0 for n!=0{ sum+=(n%10)*(n%10) n=n/10 } return sum } 就先这些了，摸了！\n1. Two Sum 题目描述 Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\n……这不是力扣第一题，跟哈希表有什么关系\n解题思路 嗯，记录 num:target-num 然后找？\nfunc twoSum(nums []int, target int) []int { targetNum:=make(map[int]int) for k,v := range nums{ targetNum[v]=k if loc,ok:=targetNum[target-v];ok\u0026amp;\u0026amp;loc!=k{ return []int{k,loc} } } return []int{} } (ﾟ∀。)那么碰到[3,3]怎么办\n看了看解析\nfunc twoSum(nums []int, target int) []int { targetNum:=make(map[int]int) for k,v := range nums{ if loc,ok:=targetNum[target-v];ok\u0026amp;\u0026amp;loc!=k{ return []int{k,loc} } targetNum[v]=k } return []int{} } (ﾟ∀。)先判断再存进去啊，这样确实可以保证不会和自己匹配了\n454. 4Sum II 题目描述 Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:\n0 \u0026lt;= i, j, k, l \u0026lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 解题思路 (ﾟ∀。)照猫画虎……吗？\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { ans:=0 countMapAB:=make(map[int]int) countMapCD:=make(map[int]int) for _,v1:=range nums1{ for _,v2:=range nums2{ countMapAB[v1+v2]++ } } for _,v1:=range nums3{ for _,v2:=range nums4{ countMapCD[v1+v2]++ } } for _,v1 := range countMapAB{ if v2,ok:=countMapCD[0-v1];ok{ ans+=v1*v2 } } return ans } 样例没过，但是搞不清楚问题在哪\n看看题解……\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { ans:=0 countMapAB:=make(map[int]int) for _,v1:=range nums1{ for _,v2:=range nums2{ countMapAB[v1+v2]++ } } for _,v1:=range nums3{ for _,v2:=range nums4{ if v,ok:=countMapAB[-v1-v2];ok{ ans+=v } } } return ans } 原来可以不用第二个哈希表……\n但是为什么第一次不对呢？\n（一番调试过后）\n(ﾟ∀。)猪鼻吧，原来应该是访问countMapCD[0-loc]，我当时还想为什么会加loc\n很好，时间快多了~ 从45%到73%\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { ans:=0 countMapAB:=make(map[int]int) countMapCD:=make(map[int]int) for _,v1:=range nums1{ for _,v2:=range nums2{ countMapAB[v1+v2]++ } } for _,v1:=range nums3{ for _,v2:=range nums4{ countMapCD[v1+v2]++ } } for loc,v1 := range countMapAB{ if v2,ok:=countMapCD[0-loc];ok{ ans+=v1*v2 } } return ans } 383. Ransom Note 题目描述 Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.\nEach letter in magazine can only be used once in ransomNote.\n解题思路 轻轻松松\nfunc canConstruct(ransomNote string, magazine string) bool { magazineList := [26]int{} for _,v := range magazine{ magazineList[rune(v)-'a']++ } for _,v := range ransomNote{ magazineList[rune(v)-'a']-- } for _,v := range magazineList{ if v\u0026lt;0{ return false } } return true } 用数组是因为性能更好一点，哈希表需要红黑树维护\n15. 3Sum 题目描述 Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\n解题思路 嗯，看到标签有双指针……\nfunc threeSum(nums []int) [][]int { ans := make([][]int,0) for key,value := range nums{ for preKey:=0;preKey\u0026lt;0;preKey++{ if preKey==key{ continue } for aftKey:=0;aftKey\u0026lt;0;aftKey++{ if aftKey==key||aftKey==preKey{ continue } if nums[aftKey]+nums[preKey]+value==0{ temp := []int{nums[aftKey],nums[preKey],value} ans=append(ans,temp) } } } } return ans } 结果全都是空的！\n摆了，看题解\n嗯，先对数组排序，因为找的是值不是坐标，然后固定第一个值，两个指针向里收缩？\nfunc threeSum(nums []int) [][]int { sort.Ints(nums) ans:=[][]int{} for key,value := range nums{ if value\u0026gt;0{ break // 若\u0026gt;0则说明没有答案，返回 } left,right:=key+1,len(nums)-1 for left\u0026lt;right{ leftValue := nums[left] rightValue := nums[right] sum := value+leftValue+rightValue if sum == 0{ // 符合条件加入 ans = append(ans,[]int{value,leftValue,rightValue}) for left\u0026lt;right\u0026amp;\u0026amp;nums[left+1]==leftValue{ // 左边收缩到不相同 left++ } for left\u0026lt;right\u0026amp;\u0026amp;nums[right-1]==rightValue{ // 右边同样 right-- } // 找到答案，同时收缩 // 因为已经排序去重，所以只收缩一边肯定不等于0 left++ right-- }else if sum\u0026gt;0{ // 大于0，收缩右边 right-- }else{ // 小于0，收缩左边 left++ } } } return ans } 样例过了，栽倒了[0,0,0,0]\n噢，猪鼻了，还要排除value的重复值\nfunc threeSum(nums []int) [][]int { sort.Ints(nums) ans:=[][]int{} for key,value := range nums{ if value\u0026gt;0{ break // 若\u0026gt;0则说明没有答案，返回 } if key\u0026gt;0\u0026amp;\u0026amp;value==nums[key-1]{ continue } left,right:=key+1,len(nums)-1 for left\u0026lt;right{ leftValue := nums[left] rightValue := nums[right] sum := value+leftValue+rightValue if sum == 0{ // 符合条件加入 ans = append(ans,[]int{value,leftValue,rightValue}) for left\u0026lt;right\u0026amp;\u0026amp;nums[left+1]==leftValue{ // 左边收缩到不相同 left++ } for left\u0026lt;right\u0026amp;\u0026amp;nums[right-1]==rightValue{ // 右边同样 right-- } // 找到答案，同时收缩 // 因为已经排序去重，所以只收缩一边肯定不等于0 left++ right-- }else if sum\u0026gt;0{ // 大于0，收缩右边 right-- }else{ // 小于0，收缩左边 left++ } } } return ans } 嘶，有点一知半解……\n18. 4Sum 前面不是做过4Sum II了嘛……\n题目描述 Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n0 \u0026lt;= a, b, c, d \u0026lt; n\na, b, c, and d are distinct.\nnums[a] + nums[b] + nums[c] + nums[d] == target\nYou may return the answer in any order.\n解题思路 好吧，好像有点不太一样……\n看标签，Array Sorting Two Pointers\n噗嗤，这还是哈希表？\n看了看评论还有超过整形的用例\n按照上一题的思路似乎没有优雅的解法，先吃饭吧！\n(ﾟ∀。)看了看题解视频，嗯，多套一层循环，然后剪枝去重……\n让我试试！\nfunc fourSum(nums []int, target int) [][]int { sort.Ints(nums) ans := [][]int{} for key,value:=range nums{ if value\u0026gt;target\u0026amp;\u0026amp;target\u0026gt;0{ break // 大于目标剪掉 } if key\u0026gt;0\u0026amp;\u0026amp;value==nums[key-1]{ continue } for i:=key+1;i\u0026lt;len(nums);i++{ iValue := nums[i] if iValue\u0026gt;target-value\u0026amp;\u0026amp;target\u0026gt;value{ break } if i\u0026gt;0\u0026amp;\u0026amp;iValue==nums[i-1]{ continue } leftKey,rightKey:=i+1,len(nums)-1 for leftKey\u0026lt;rightKey{ leftValue,rightValue:=nums[leftKey],nums[rightKey] sum:=leftValue+rightValue+iValue+value if sum==target{ ans=append(ans,[]int{leftValue,rightValue,iValue,value}) // 去重 for leftKey\u0026lt;rightKey\u0026amp;\u0026amp;leftValue==nums[leftKey+1]{ leftKey++ } for leftKey\u0026lt;rightKey\u0026amp;\u0026amp;rightValue==nums[rightKey-1]{ rightKey-- } leftKey++ rightKey-- }else if sum\u0026gt;target{ rightKey-- }else{ leftKey++ } } } } return ans } 在[2,2,2,2]没过，看起来应该是去重的时候出现了点问题……\n找到了，i\u0026gt;0 -\u0026gt; i\u0026gt;key+1\nfunc fourSum(nums []int, target int) [][]int { sort.Ints(nums) ans := [][]int{} for key,value:=range nums{ if value\u0026gt;target\u0026amp;\u0026amp;target\u0026gt;0{ break // 大于目标剪掉 } if key\u0026gt;0\u0026amp;\u0026amp;value==nums[key-1]{ continue } for i:=key+1;i\u0026lt;len(nums);i++{ iValue := nums[i] if iValue\u0026gt;target-value\u0026amp;\u0026amp;target\u0026gt;value{ break } if i\u0026gt;key+1\u0026amp;\u0026amp;iValue==nums[i-1]{ continue } leftKey,rightKey:=i+1,len(nums)-1 for leftKey\u0026lt;rightKey{ leftValue,rightValue:=nums[leftKey],nums[rightKey] sum:=leftValue+rightValue+iValue+value if sum==target{ ans=append(ans,[]int{leftValue,rightValue,iValue,value}) // 去重 for leftKey\u0026lt;rightKey\u0026amp;\u0026amp;leftValue==nums[leftKey+1]{ leftKey++ } for leftKey\u0026lt;rightKey\u0026amp;\u0026amp;rightValue==nums[rightKey-1]{ rightKey-- } leftKey++ rightKey-- }else if sum\u0026gt;target{ rightKey-- }else{ leftKey++ } } } } return ans } 和前面的4SumII区别还是不小的，前者是四个数组可以用哈希表，但是这里是一个数组，双指针效率更高一点。\n力扣哈希表也完结了，虽然最后两道题明明就是双指针……\n总结 哈希表都是用来快速判断一个元素是否出现集合里。\n","date":"2022-11-22","permalink":"https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A3%E5%93%88%E5%B8%8C%E8%A1%A8/","tags":["力扣"],"title":"力扣哈希表"},{"content":"每日一题！\n只记录自己会做且有思考的题目\n1805. Number of Different Integers in a String 题目描述 You are given a string word that consists of digits and lowercase English letters.\nYou will replace every non-digit character with a space. For example, \u0026ldquo;a123bc34d8ef34\u0026rdquo; will become \u0026quot; 123 34 8 34\u0026quot;. Notice that you are left with some integers that are separated by at least one space: \u0026ldquo;123\u0026rdquo;, \u0026ldquo;34\u0026rdquo;, \u0026ldquo;8\u0026rdquo;, and \u0026ldquo;34\u0026rdquo;.\nReturn the number of different integers after performing the replacement operations on word.\nTwo integers are considered different if their decimal representations without any leading zeros are different.\n解题思路 一眼哈希表，但是Go怎么做呢？先拿py做吧\nclass Solution: def numDifferentIntegers(self, word: str) -\u0026gt; int: alphabet = 'abcdefghijklmnopqrstuvwxyz' sep='' sepDict = {} for i in word: if i in alphabet: if sep!='': sepDict[int(sep)]=1 sep='' else: sep+=i if sep!='': sepDict[int(sep)]=1 return len(sepDict) 然后看看题解……双指针还行\nfunc numDifferentIntegers(word string) int { integersMap:=map[string]bool{} length := len(word) key:=0 for{ // 扫描到数字 for key\u0026lt;length\u0026amp;\u0026amp;!unicode.IsDigit(rune(word[key])){ key++ } if key==length{ break } // 前指针出发扫描数字直到出现字母 preKey:=key for preKey\u0026lt;length\u0026amp;\u0026amp;unicode.IsDigit(rune(word[preKey])){ preKey++ } // 去除重复0 for preKey-key\u0026gt;1\u0026amp;\u0026amp;word[key]=='0'{ key++ } // 加入map，并复位进行下一次扫描 integersMap[word[key:preKey]]=true key=preKey } return len(integersMap) } ","date":"2022-10-25","permalink":"https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","tags":["力扣"],"title":"力扣每日一题"},{"content":"A named and an unnamed type are always different.\n简单的说在刚刚遇到了一个小Bug\ntype Message []MessageSegment func (ctx *Ctx) Send(msg interface{}) MessageID { event := ctx.Event m, ok := msg.(Message) if ok{ // Do something } } msg := make([]MessageSegment, n) Send(msg) 此时类型断言会认为msg不属于Message类型，从而换一种方式解析。\n在谷歌上查阅type assertion alias type golang，可以发现一篇15年的邮件列表，上面出现了类似的问题，最后开发者给予了解答，简而言之就是简介的那句话\nA named and an unnamed type are always different.\n一个被命名的类型和不被命名的类型总是不一样的。\n此外还给出了Go的类型设计，虽然一下子没看太懂就是\n","date":"2022-10-02","permalink":"https://shudorcl.github.io/post/2022%E5%B9%B410%E6%9C%882%E6%97%A5go%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/","tags":null,"title":"Go的类型别名和类型断言"},{"content":"想了想没必要一道题发一篇，干脆就一章塞一起吧！\n203. Remove Linked List Elements 题目描述 Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.\n解题思路 非常简单，只要记录头尾然后乾坤大挪移即可\n说是这么说，但还是处理一些特殊情况需要注意\nfunc removeElements(head *ListNode, val int) *ListNode { curr:=head // 清理头部 for curr!=nil\u0026amp;\u0026amp;curr.Val==val{ curr=curr.Next } // 如果头部依然为空返回空 if curr==nil{ return nil } nhead := curr pre := curr // 因为头部处理过了放心到下一个 curr = curr.Next for curr!=nil{ // 不能是curr.Next!=nil，会报错 if curr.Val==val{ pre.Next=curr.Next }else{ pre=curr } curr=curr.Next } return nhead } 好了，我睡了！\n707. Design Linked List 题目描述 Design your implementation of the linked list. You can choose to use a singly or doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.\nImplement the MyLinkedList class:\nMyLinkedList() Initializes the MyLinkedList object. int get(int index) Get the value of the indexth node in the linked list. If the index is invalid, return -1. void addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. void addAtTail(int val) Append a node of value val as the last element of the linked list. void addAtIndex(int index, int val) Add a node of value val before the indexth node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted. void deleteAtIndex(int index) Delete the indexth node in the linked list, if the index is valid.\n可笑，学过数据结构就知道这种事情非常简单！\n解题思路 手写链表比较细，没什么需要注意的，不过双链表需要有个哨兵头尾，这点上课的时候好像没学过？\n反转链表 题目描述 206. Reverse Linked List\nGiven the head of a singly linked list, reverse the list, and return the reversed list.\n解题思路 非常简单，考虑每一个节点，只要把尾指针指向前个节点即可，这么思考下去，则需要记录前节点\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { curr:=head var pre *ListNode for curr!=nil{ next:=curr.Next curr.Next = pre pre = curr curr=next } return pre } 再看看其它解法？\n2022年10月22日\n和舍友讨论，可以把头节点拆出来，然后遍历一个个使用头插法\n两两交换链表中的节点 题目链接\n题目描述 Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list\u0026rsquo;s nodes (i.e., only nodes themselves may be changed.)\n解题思路 思维好差。。。摸了\n好好好，我恢复了，总之也是比较简单的链表操作，画出图来就能解决\n不过这里学到了一点，可以使用虚拟头节点dummy方便操作，嗯，似乎有点像，双链表的时候的哨兵？\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func swapPairs(head *ListNode) *ListNode { dummy := \u0026amp;ListNode{ Next: head, } //head=list[i] //pre=list[i-1] pre := dummy for head != nil \u0026amp;\u0026amp; head.Next != nil { pre.Next = head.Next next := head.Next.Next head.Next.Next = head head.Next = next //pre=list[(i+2)-1] pre = head //head=list[(i+2)] head = next } return dummy.Next } 就这样吧\n19.删除链表的倒数第N个节点 题目地址\n题目描述 Given the head of a linked list, remove the nth node from the end of the list and return its head.\n解题思路 什么啊，这一看不是简单至极？\n再看看标签，双指针，原来如此，一次解的思路我已经有了！\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { dummy:=\u0026amp;ListNode{0,head} pre:=dummy curr:=head pioneer:=head // 第一次重定位，前指针先走n步 for i:=0;i\u0026lt;n;i++{ pioneer=pioneer.Next } // 第二次定位，找到删除节点 for pioneer!=nil{ pioneer=pioneer.Next curr=curr.Next pre=pre.Next } // 删除 pre.Next=curr.Next return dummy.Next } 哼，易如反掌\n02.07. Intersection of Two Linked Lists LCCI 题目链接\n题目描述 Given two (singly) linked lists, determine if the two lists intersect. Return the inter­ secting node. Note that the intersection is defined based on reference, not value. That is, if the kth node of the first linked list is the exact same node (by reference) as the jth node of the second linked list, then they are intersecting.\n解题思路 一开始不会做，不过看到图就懂了\n原来MD图片是要加感叹号啊\n显然，只要算出长度差然后一个一个比即可\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getIntersectionNode(headA, headB *ListNode) *ListNode { curr:=headA lenA:=0 lenB:=0 for curr!=nil{ lenA++ curr=curr.Next } curr=headB for curr!=nil{ lenB++ curr=curr.Next } gap:=lenA-lenB currA:=headA currB:=headB if gap\u0026gt;0{ // A比B长先动A for i:=0;i\u0026lt;gap;i++{ currA=currA.Next } }else{ for i:=gap;i\u0026lt;0;i++{ currB=currB.Next } } for currA!=currB{ currA=currA.Next currB=currB.Next } return currA } 其他解法 哈希表，A表入哈希，然后看B表有无\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode { vis := map[*ListNode]bool{} for tmp := headA; tmp != nil; tmp = tmp.Next { vis[tmp] = true } for tmp := headB; tmp != nil; tmp = tmp.Next { if vis[tmp] { return tmp } } return nil } Linked List Cycle II 题目链接\n题目描述 Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail\u0026rsquo;s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\nDo not modify the linked list.\n解题思路 在之前浅看CS61C的时候讲到过一个算法，总之就是双指针一个两步一个一步判断有无环，但是写出来后发现，判断有无环后呢？怎么知道入口？\n于是就去看题解了\n嗯，等量关系。。。不过我饿了先去吃饭\n这一去就是三周。。。\n做点简单的笔记\n我们假设入口距离为x，相遇时在环内走了y，剩余环长为z\n相遇的时候，快指针走了x+n*(y+z)步，而慢指针走了x+y步，又有2*(x+y)=x+n*(y+z)，稍微计算一下，就有\nx=(n-1)*(y+z)+z，那么若n=1，则有x=z，所以此时只要在第一次相遇点，把快指针挪回初始点，找到他们再度相遇的点，即为入口\n若n!=1呢？那么也是一样处理，只不过慢指针会多绕n-1圈\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func detectCycle(head *ListNode) *ListNode { fast:=head slow:=head for fast!=nil\u0026amp;\u0026amp;fast.Next!=nil{ // 判断有无环 fast=fast.Next.Next slow=slow.Next if fast==slow{ // 相遇，有环 fast = head // 挪回开头寻找 for fast!=slow{ fast = fast.Next slow = slow.Next } return fast // 相遇返回 } } return nil } 哟西，链表算是完结了！\n","date":"2022-09-23","permalink":"https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A3%E9%93%BE%E8%A1%A8/","tags":["力扣"],"title":"力扣链表"},{"content":"大家好啊，我是dorcl，今天来点大家想看的东西奥。\n在翻译分歧FF的时候碰到了得克萨斯独立宣言的文本，没事干稍微翻译一下~\n助手：DeepL娘 火山娘\n翻译 When a government has ceased to protect the lives, liberty and property of the people, from whom its legitimate powers are derived, and for the advancement of whose happiness it was instituted, and so far from being a guarantee for the enjoyment of those inestimable and inalienable rights, becomes an instrument in the hands of evil rulers for their oppression.\n当一个政府不再保护人民的生命、自由和财产时，但它的合法权力却来自于人民，它的建立也是为了促进人民的幸福，那么此时它不再是享受这些不可估量和不可剥夺的权利的保障，而是成为邪恶统治者手中压迫的工具。\nWhen the Federal Republican Constitution of their country, which they have sworn to support, no longer has a substantial existence, and the whole nature of their government has been forcibly changed, without their consent, from a restricted federative republic, composed of sovereign states, to a consolidated central military despotism, in which every interest is disregarded but that of the army and the priesthood, both the eternal enemies of civil liberty, the everready minions of power, and the usual instruments of tyrants.\n当他们曾经宣誓支持的联邦共和国宪法不再存续，整个政府的类型也在未被宪法允许下被强行更改，这个国家便从一个受限制的，由主权国家组成的联邦共和国，变成了一个集权化的军事专制政府，在这之中除了军队和神职人员的利益外，一切的利益都被忽视，他们将永远是公民自由的永恒之敌，永远是权力的残酷爪牙，永远是暴君的趁手工具。\nWhen, long after the spirit of the constitution has departed, moderation is at length so far lost by those in power, that even the semblance of freedom is removed, and the forms themselves of the constitution discontinued, and so far from their petitions and remonstrances being regarded, the agents who bear them are thrown into dungeons, and mercenary armies sent forth to force a new government upon them at the point of the bayonet.\nWhen, in consequence of such acts of malfeasance and abdication on the part of the government, anarchy prevails, and civil society is dissolved into its original elements. In such a crisis, the first law of nature, the right of self-preservation, the inherent and inalienable rights of the people to appeal to first principles, and take their political affairs into their own hands in extreme cases, enjoins it as a right towards themselves, and a sacred obligation to their posterity, to abolish such government, and create another in its stead, calculated to rescue them from impending dangers, and to secure their future welfare and happiness.\nNations, as well as individuals, are amenable for their acts to the public opinion of mankind. A statement of a part of our grievances is therefore submitted to an impartial world, in justification of the hazardous but unavoidable step now taken, of severing our political connection with the Mexican people, and assuming an independent attitude among the nations of the earth.\nThe Mexican government, by its colonization laws, invited and induced the Anglo-American population of Texas to colonize its wilderness under the pledged faith of a written constitution, that they should continue to enjoy that constitutional liberty and republican government to which they had been habituated in the land of their birth, the United States of America.\nIn this expectation they have been cruelly disappointed, inasmuch as the Mexican nation has acquiesced in the late changes made in the government by General Antonio Lopez de Santa Anna, who having overturned the constitution of his country, now offers us the cruel alternative, either to abandon our homes, acquired by so many privations, or submit to the most intolerable of all tyranny, the combined despotism of the sword and the priesthood.\nIt has sacrificed our welfare to the state of Coahuila, by which our interests have been continually depressed through a jealous and partial course of legislation, carried on at a far distant seat of government, by a hostile majority, in an unknown tongue, and this too, notwithstanding we have petitioned in the humblest terms for the establishment of a separate state government, and have, in accordance with the provisions of the national constitution, presented to the general Congress a republican constitution, which was, without just cause, contemptuously rejected.\nIt incarcerated in a dungeon, for a long time, one of our citizens, for no other cause but a zealous endeavor to procure the acceptance of our constitution, and the establishment of a state government.\nIt has failed and refused to secure, on a firm basis, the right of trial by jury, that palladium of civil liberty, and only safe guarantee for the life, liberty, and property of the citizen.\nIt has failed to establish any public system of education, although possessed of almost boundless resources, (the public domain,) and although it is an axiom in political science, that unless a people are educated and enlightened, it is idle to expect the continuance of civil liberty, or the capacity for self government.\nIt has suffered the military commandants, stationed among us, to exercise arbitrary acts of oppression and tyrrany, thus trampling upon the most sacred rights of the citizens, and rendering the military superior to the civil power.\nIt has dissolved, by force of arms, the state Congress of Coahuila and Texas, and obliged our representatives to fly for their lives from the seat of government, thus depriving us of the fundamental political right of representation.\nIt has demanded the surrender of a number of our citizens, and ordered military detachments to seize and carry them into the Interior for trial, in contempt of the civil authorities, and in defiance of the laws and the constitution.\nIt has made piratical attacks upon our commerce, by commissioning foreign desperadoes, and authorizing them to seize our vessels, and convey the property of our citizens to far distant ports for confiscation.\nIt denies us the right of worshipping the Almighty according to the dictates of our own conscience, by the support of a national religion, calculated to promote the temporal interest of its human functionaries, rather than the glory of the true and living God.\nIt has demanded us to deliver up our arms, which are essential to our defence, the rightful property of freemen, and formidable only to tyrannical governments.\nIt has invaded our country both by sea and by land, with intent to lay waste our territory, and drive us from our homes; and has now a large mercenary army advancing, to carry on against us a war of extermination.\nIt has, through its emissaries, incited the merciless savage, with the tomahawk and scalping knife, to massacre the inhabitants of our defenseless frontiers.\nIt hath been, during the whole time of our connection with it, the contemptible sport and victim of successive military revolutions, and hath continually exhibited every characteristic of a weak, corrupt, and tyrranical government.\nThese, and other grievances, were patiently borne by the people of Texas, untill they reached that point at which forbearance ceases to be a virtue. We then took up arms in defence of the national constitution. We appealed to our Mexican brethren for assistance. Our appeal has been made in vain. Though months have elapsed, no sympathetic response has yet been heard from the Interior. We are, therefore, forced to the melancholy conclusion, that the Mexican people have acquiesced in the destruction of their liberty, and the substitution therfor of a military government; that they are unfit to be free, and incapable of self government.\nThe necessity of self-preservation, therefore, now decrees our eternal political separation.\nWe, therefore, the delegates with plenary powers of the people of Texas, in solemn convention assembled, appealing to a candid world for the necessities of our condition, do hereby resolve and declare, that our political connection with the Mexican nation has forever ended, and that the people of Texas do now constitute a free, Sovereign, and independent republic, and are fully invested with all the rights and attributes which properly belong to independent nations; and, conscious of the rectitude of our intentions, we fearlessly and confidently commit the issue to the decision of the Supreme arbiter of the destinies of nations.\n","date":"2022-09-14","permalink":"https://shudorcl.github.io/post/%E5%BE%97%E5%85%8B%E8%90%A8%E6%96%AF%E7%8B%AC%E7%AB%8B%E5%AE%A3%E8%A8%80%E7%BF%BB%E8%AF%91/","tags":["杂物"],"title":"得克萨斯独立宣言翻译"},{"content":"虽然已经决定了申不上就在家里啃老，但是做点lc总归没有坏处。\n这里直接按照代码随想录的顺序做题，不多一天一道这样。\n不过作者给公众号知识星球导流和在豆瓣刷好评这些行为实在是太败我好感了。。。\n二分查找 题目描述 Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 Example 2:\nInput: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1 主要是注意题目的降序\n解题思路 作为上过数据结构的人，二分查找大概的思想还是记得的，无非是比较中间值，大于就取后半边，小于就取前半边，但是，在实际写代码的时候就犯难了。。。一开始想用递归做，后面发现根本不会写，果然没训练过就是这种水平。\n我当然知道自己什么水平，于是马上去oiwiki复习了一番，并把它的CPP模板改成了Go\nfunc search(nums []int, target int) int { ret,mid:=-1,0 start,end:=0,len(nums)-1 for start\u0026lt;=end{ mid = start+((end-start)\u0026gt;\u0026gt;1) if nums[mid]\u0026lt;target{ start = mid+1 } else if nums[mid]\u0026gt;target{ end = mid-1 } else{ ret = mid break } } return ret } 唔，就我的理解而言，迭代方式的二分查找主要是根据查找结果更新start/end从而更新mid\n这里有两个点值得一提，一个是len(nums)理所当然会导致越界，需要-1，果然我还是急躁鲁莽，没救了\n还有就是oiwiki上取平均用的是(end-start)\u0026gt;\u0026gt;1，我们知道，右移n位相当于除以$2^n$，是非常妙的避免溢出的方法！\n（等等，为什么会溢出）\n（这里应该还有递归写法，但是先摸了）\n作为随时可能鸽的lc之旅的开始。。。今天就这些了！玩游戏！\n移除元素 题目描述 Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nEx1.\nInput: nums = [3,2,2,3], val = 3 Output: 2, nums = [2,2,_,_] Explanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores). 解题思路 一看题目当然懵了，不开空间怎么做。于是去看了看标签和提示，大概就是告诉我们可以用双指针来做，于是我马上去搜索双指针，找几个博客稍微看看。\n五分钟后，很好，我大概了解了，于是在几次提交失败后整出了这样的代码\nfunc removeElement(nums []int, val int) int { tail:=len(nums)-1 for tail\u0026gt;=0 { if nums[tail]!=val{ break } tail-- } for head:=0;head\u0026lt;=tail;head++{ if nums[head]==val{ nums[head]=nums[tail] tail-- } } return tail+1 } 毫无疑问这当然是错的\n怎么想的呢，主要是想到可以把重复的元素移到后面，但是这样实际上忽略了一点，就是不能保证后面的元素不是需要移除的，然后沿着这个错误的思路下去思考，就感觉完全不会写了，于是看了看评论区\u0026hellip;\nfunc removeElement(nums []int, val int) int { tail:=0 for head:=0;head\u0026lt;len(nums);head++{ if nums[head]!=val{ nums[tail]=nums[head] tail++ } } return tail } 简单非常多！\n这样实际上才算是典型的双指针，一个快一个慢，因为我们考虑的只是输出数组的长度，那么，只要nums[head]!=val，就把需要输出的元素向前移动，双指针一起向前移动，反之，则tail不移动，不将其纳入输出元素中。\n然后再看看力扣官方题解中的第二种解法\u0026hellip;\nfunc removeElement(nums []int, val int) int { left, right := 0, len(nums) for left \u0026lt; right { if nums[left] == val { nums[left] = nums[right-1] right-- } else { left++ } } return left } ？\n前面所说，问题在于不能保证后面的元素不是需要移除的，这里则给出了解决的方法，如果飞过去的元素依然等于val，那么left就不进行移动，继续让right往下查找元素，这样，当两个指针交会时，结果就出来了。\n此外，还有一个暴力解法：\n// 时间复杂度：O(n^2) // 空间复杂度：O(1) class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int size = nums.size(); for (int i = 0; i \u0026lt; size; i++) { if (nums[i] == val) { // 发现需要移除的元素，就将数组集体向前移动一位 for (int j = i + 1; j \u0026lt; size; j++) { nums[j - 1] = nums[j]; } i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位 size--; // 此时数组的大小-1 } } return size; } }; 彩蛋：Python一刀秒 论Python为什么是神\nclass Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: while val in nums: nums.remove(val) return len(nums) 好了，今天就这样了，该去背单词了！\n\u0026hellip;或许有空多做几道变式比较好\n有序数组的平方 题目描述 Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\n解题思路 暴力 先平方再排序\nfunc sortedSquares(nums []int) []int { for k,v:= range nums{ nums[k]=v*v } length:=len(nums) for i:=0;i\u0026lt;length;i++{ for j:=0;j\u0026lt;length-1-i;j++{ if nums[j]\u0026gt;nums[j+1]{ nums[j],nums[j+1]=nums[j+1],nums[j] } } } return nums } 不过这里实际上可以用sort.Ints(ans)来解决，我这里手写了一个冒泡排序，顺便当复习了）\n双指针 然后看到题目有双指针，心想这次得整一下，尝试了几回后想到可以从非零位置开始，一个往左一个往右进行比较加入，两边到头后跳出循环\nfunc sortedSquares(nums []int) []int { start,count:=0,0 length:=len(nums) if length==1{ nums[0]=nums[0]*nums[0] return nums } newNums:=make([]int,length) for k,v:= range nums{ if v\u0026gt;=0{ start=k break } } left,right:=start-1,start for{ leftValue:=nums[left]*nums[left] rightValue:=nums[right]*nums[right] if leftValue\u0026lt;rightValue{ newNums[count]=leftValue if left\u0026gt;0{ left-- } }else{ newNums[count]=rightValue if right\u0026lt;length-1{ right++ } } count++ if left==0\u0026amp;\u0026amp;right==length-1{ break } } return newNums } 但是，但是，它运行样例结果不对啊！\n最后没有办法去看题解了\n原来如此.jpg\nfunc sortedSquares(nums []int) []int { start:=0 length:=len(nums) if length==1{ nums[0]=nums[0]*nums[0] return nums } ans:=make([]int,0,length) for k,v:= range nums{ start=k if v\u0026gt;=0{ break } } for left,right:=start-1,start;left\u0026gt;=0||right\u0026lt;length;{ if left\u0026lt;0{ ans = append(ans,nums[right]*nums[right]) right++ } else if right==length{ ans = append(ans,nums[left]*nums[left]) left-- } else if nums[left]*nums[left]\u0026lt;nums[right]*nums[right]{ ans = append(ans,nums[left]*nums[left]) left-- } else{ ans = append(ans,nums[right]*nums[right]) right++ } } return ans } 第一次遇到[-5,-3,-2,-1]时还无法通过，因为前面判断非负位置的时候没有考虑全负。。。\n先这样发布了！要吃午饭了！\n长度最小的子数组 题目描述 209. 长度最小的子数组\nGiven an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, \u0026hellip;, numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.\n解题思路 首先看看标签！有Silding Window和Prefix Sum，显然是我完全不会的\n于是先用暴力方法做一下\n暴力法 func minSubArrayLen(target int, nums []int) int { count,length,minlength:=0,0,len(nums) for i :=0;i\u0026lt;len(nums);i++{ count,length=0,0 for v :=i;v\u0026lt;len(nums);v++{ count+=nums[v] length++ if count\u0026gt;target{ break } } if length\u0026lt;minlength{ minlength=length } } return length } 但是怎么都算得结果是1，懒得debug了，直接看题解！\nfunc minSubArrayLen(s int, nums []int) int { n := len(nums) if n == 0 { return 0 } ans := math.MaxInt32 for i := 0; i \u0026lt; n; i++ { sum := 0 for j := i; j \u0026lt; n; j++ { sum += nums[j] if sum \u0026gt;= s { ans = min(ans, j - i + 1) break } } } if ans == math.MaxInt32 { return 0 } return ans } func min(x, y int) int { if x \u0026lt; y { return x } return y } （7月30日在这里断了，8月4日继续！） 好像思路差不多诶。。。\n试下改一改边界条件之类的\nfunc minSubArrayLen(target int, nums []int) int { count,length,minlength:=0,0,len(nums) if minlength==0{ return 0 } minlength = math.MaxInt32 for i :=0;i\u0026lt;len(nums);i++{ count=0 for v :=i;v\u0026lt;len(nums);v++{ count+=nums[v] if count\u0026gt;=target{ length = v-i+1 if length\u0026lt;minlength{ minlength=length } break } } if minlength == math.MaxInt32{ return 0 } } return minlength } 从这里分析可以发现，一开始的做法有很多问题：\n忽视了题目已经明确给出条件为is greater than or equal to target，边界条件依然为＞\n导致每次返回为1的原因之一，是每次循环都进行一次比较，自然是最短的为1的串成为答案\n同样，应该返回的是minlength，而非length，大概是没救了罢（大悲）\n题解很好，但是TLE了\n接着我们看看题解介绍的其他方法（咕）\n滑动窗口 和前面几篇的双指针差不多，一前一后，前指针先往前扫描，如果sum\u0026gt;=target则记录长度，后指针再往前收缩，如此反复。\n试一下自己写。。。\n惹啊，不会，于是决定摆烂看代码随想录的视频\nfunc minSubArrayLen(target int, nums []int) int { ans := math.MaxInt32 n:=len(nums) sum:=0 for i,j:=0,0;i\u0026lt;n;i++{ sum+=nums[i] // 扫描到sum\u0026gt;=target for sum\u0026gt;=target{ // 如果sum\u0026gt;=target，则更新 subLength := i-j+1 // 计算长度 sum-=nums[j] // 减去收缩的元素 if subLength\u0026lt;ans{ // 此时，如果依然满足sum\u0026gt;=target，则更新答案 ans = subLength } j++ // 继续收缩 } // 如果不满足sum\u0026gt;=target了呢？那么前指针向前继续扫描 } if ans==math.MaxInt32{ // 如果ans值没有变化，则赋0 ans = 0 } return ans } 至少有讲解视频，之前败的好感回来了一些。。。\n前缀和+二分查找 首先，什么是前缀和？因为太晚了今天先这样了，我要睡觉了！\n看看OiWiki怎么说：\n前缀和 定义 前缀和可以简单理解为「数列的前n项的和」，是一种重要的预处理方式，能大大降低查询的时间复杂度。\n噢，原来是这样啊（棒读）\n大概就是处理出一个前缀和数组sum []int，然后对它进行二分查找，找到一个sum[i]-sum[j]\u0026gt;=target的位置。。。\n看了看没太看懂，摸了\n螺旋矩阵II 题目描述 Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n解题思路 看起来稀松平常，但是——这个东西怎么遍历啊！\n完全不懂，于是直接看题解吧\n看了看视频解析后，我已经完全明白了！\n非常简单，就是剥洋葱！循环一个外圈后，再按照这样的模式去循环内圈！\n那么，外圈怎么循环呢？参考视频中的思路，就是每条边遍历首个节点，但是不遍历最后一个节点！\nOK，那么代码试一下！\nfunc generateMatrix(n int) [][]int { ans := make([][]int, n) for i := range ans { ans[i] = make([]int, n) } count := 1 for i:=0;i\u0026lt;n/2;i++{ // 一次循环一个外圈 // 右 for j:=i;j\u0026lt;n-i-1;j++{ ans[i][j]=count count++ } // 下 for j:=i;j\u0026lt;n-i-1;j++{ ans[j][n-i-1]=count count++ } // 左 for j:=n-i-1;j\u0026gt;i;j--{ ans[n-i-1][j]=count count++ } // 上 for j:=n-i-1;j\u0026gt;i;j--{ ans[j][i]=count count++ } } // 如果是奇数补上中心 if n%2==1{ ans[n/2][n/2]=n*n } return ans } 惹，第一次提交忘记加上补中心了。。。\n值得一提的是，这里的i实际上身兼多职，如果用一种比较啰嗦的方式写的话可以是这样\nfunc generateMatrix(n int) [][]int { ans := make([][]int, n) for i := range ans { ans[i] = make([]int, n) } count := 1 start := 0 offset := 0 for i:=0;i\u0026lt;n/2;i++{ // 一次循环一个外圈 // 右 for j:=start;j\u0026lt;n-offset-1;j++{ ans[start][j]=count count++ } // 下 for j:=start;j\u0026lt;n-offset-1;j++{ ans[j][n-offset-1]=count count++ } // 左 for j:=n-offset-1;j\u0026gt;start;j--{ ans[n-offset-1][j]=count count++ } // 上 for j:=n-offset-1;j\u0026gt;start;j--{ ans[j][start]=count count++ } start++ offset++ } // 如果是奇数补上中心 if n%2==1{ ans[n/2][n/2]=n*n } return ans } 这里就比较清晰了，每一次循环的起始位置start，每次循环的末位置偏移offset和循环轮次i都是每轮加一，所以自然可以自增！\n好了，今天就这样了，该学英语了！\n","date":"2022-07-25","permalink":"https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A31-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","tags":["力扣"],"title":"力扣数组"},{"content":" 转载自 https://stdrc.cc/style-guides/chinese.html\nRC 大佬的中文写作指南，转载一份留作参考\n空格 中英文之间加空格 正确示例：\n在 Python 中，我们使用 class 关键字来声明类。\n错误示例：\n在Python中，我们使用class关键字来声明类。\n在 Python中，我们使用 class关键字来声明类。\n中文与数字之间加空格 正确示例：\n他只用了 100 行不到的代码就实现了那个复杂的功能。\n错误示例：\n他只用了100行不到的代码就实现了那个复杂的功能。\n数字与英文单位之间加空格、与符号单位之间不加空格 正确示例：\n我有一块 512 GB 的硬盘。\n今天气温 23˚C，有 70% 的可能性下雨。\n错误示例：\n我有一块 512GB 的硬盘。\n今天气温 23 ˚C，有 70 % 的可能性下雨。\n全角标点与其它字符之间不加空格 正确示例：\n他有一台 Mac。\n错误示例：\n他有一台 Mac 。\n中文与英文半角符号之间加空格 正确示例：\n很多人都在学习 C++ 这门语言。\ncount-- 表示给 count 变量减 1。\n错误示例：\n很多人都在学习 C++这门语言。\ncount--表示给 count 变量减 1。\n行的开头和结尾不应出现空白字符 正确示例：\n这是一行文字。\n错误示例：\n..这是一行文字。..\n（上面的「.」表示空格）\n除特殊场合（如代码中）外，不应有两个或更多空格连续出现 正确示例：\n我喜欢 GitHub。\n错误示例：\n我喜欢..GitHub。\n（上面的「.」表示空格）\n如果确实需要表示多个空格，用「.」代替。\n示例：\n「我喜欢..GitHub。」这样的格式是不对的。\n链接与文字之间加空格（个人习惯） 示例：\n如需下载，请点击 这里。\n标点、数字、符号 在中文语境下使用中文全角标点（除数学运算符） 正确示例：\n你好，请问《朝花夕拾》这本书还有的卖吗？\nAndroid Studio 从 1.3 版本开始加入了 NDK（Native Development Kit）支持。\n错误示例：\n你好,请问\u0026lt;朝花夕拾\u0026gt;这本书还有的卖吗?\nAndroid Studio 从 1.3 版本开始加入了 NDK(Native Development Kit)支持.\n使用半角数字 正确示例：\n他拿了 1000 元。\n错误示例：\n他拿了１０００元。\n使用引号引用英文短语、句子时，引号内使用英文半角标点 正确示例：\n他的座右铭是「Stay hungry, stay foolish.」。\n错误示例：\n他的座右铭是「Stay hungry，stay foolish。」。\n使用正确的省略号和破折号 正确的省略号和破折号占两格，每格分别是「…」和「—」。使用了省略号则不宜同时使用「等等」。\n正确示例：\n编程语言有很多，如 C、C++、Java……\n他刚刚做了一个重要的决定——辞职。\n错误示例：\n编程语言有很多，如 C、C++、Java…\n编程语言有很多，如 C、C++、Java\u0026hellip;\n编程语言有很多，如 C、C++、Java。。。\n编程语言有很多，如 C、C++、Java……等等\n他刚刚做了一个重要的决定 - 辞职。\n他刚刚做了一个重要的决定-辞职。\n他刚刚做了一个重要的决定—辞职。\n正确地使用书名号 书名、篇名、报纸名、杂志名、歌曲名、影剧名和图表名，用书名号标识，括号用作注明翻译或原文时应置于书名号外。\n正确示例：\n《旺达与巨像》（Shadow of the Colossus）好玩吗？\n错误示例：\n《旺达与巨像（Shadow of the Colossus）》好玩吗？\n避免叠用叹号、问号和其它不适合叠用的标点 正确示例：\n这就是你的最终态度了？\n是的，我已经决定了！如果再这么下去的话……\n错误示例：\n这就是你的最终态度了？？\n是的，我已经决定了！！如果再这么下去的话。。。\n在表达同时包含疑惑和感叹的语气时，可连用「？！」 示例：\n这么点困难就能把我们吓倒吗？！\n标示被注释的词语时，使用方头括号 示例：\n【C 语言】一种通用的编程语言，广泛用于系统软件与应用软件的开发。\n注意区分中文数字和阿拉伯数字的使用场景 在表示数据、编号、公历年月日时，使用阿拉伯数字；在表示农历年月日、概数，或数量较小且使用汉字数字较自然时，使用汉字数字。如果汉字数字和阿拉伯数字在书写的简洁性和辨识的清晰性两方面没有明显差异时，两者均可，但应保持全文同类情况选择相同；如果数字很大，在中文语境下，使用「万」「亿」等汉字数字单位，其余部分使用阿拉伯数字，在英文或描述 IT 相关内容的语境下，使用纯阿拉伯数字，并对四位以上的数字从右往左每隔三个数字标记一个英文半角逗号。\n示例：\n3 月 20 日，他跑了 20.8 km。\n这段代码的第 130 行有一个错误。\n今天是农历八月初八。\n你可以使用「4 个月」，或「四个月」。\n这个人才二三十岁，看起来却像个六十几岁的老人。\n中国有约 14 亿人口。\nC 语言中，一个 32 位 int 型变量可以保存最大的数字为 2,147,483,647。\n使用直角引号代替弯引号（个人习惯） 正确示例：\n他常被人称为「冷场王」。\n他问我：「『天无绝人之路』这句话是出自哪里的？」\n错误示例：\n他常被人称为“冷场王”。\n他问我：“‘天无绝人之路’这句话是出自哪里的？”\n标有引号或书名号的并列成分之间不使用顿号，若有其它成分插在引号或书名号之间则使用顿号（个人习惯） 示例：\n《红楼梦》《三国演义》《西游记》《水浒传》是中国的四大名著。\n李白的「白发三千丈」（《秋浦歌》）、「朝如青丝暮成雪」（《将进酒》）都是脍炙人口的诗句。\n在应用／商品标题中使用英文半角标点（个人习惯） 正确示例：\nJigsaw (J 拼图)\n错误示例：\nJigsaw（J 拼图）\n字、词、句 使用「你」而不是「您」 除非文本的主要阅读者是上级、长辈、客户等，否则应使用「你」。\n部分形近、同义词汇，固定一种写法 使用「唯一」代替「惟一」，「只需」「需要」代替「只须」「须要」（如需特别强调，使用「必须」），指代事物用「其它」，指代人用「其他」。\n正确地使用「的」「地」「得」 示例：\n他是一个很高的人。\n他能够很快地写出优质的代码。\n他跑得很快。\n专有名词使用正确的书写格式 按照官方给出的格式或普遍认可的格式书写，包括空格、英文大小写等。\n示例：\n豆瓣FM、QQ音乐、360安全卫士、Twitter、Google+、Facebook、GitHub、JavaScript、Python、PHP、iPad Air 2、iPad mini 4、MacBook Pro 等\n避免使用无实际意义或指代不清的人称代词 正确示例：\n怎样看待 Google 推出的社交网络产品 Google+ ？\niCloud 为用户带来了什么？或：iCloud 为开发者带来了什么？\n错误示例：\nGoogle 推出了社交网络产品 Google+ ，大家怎么看？\niCloud 为我们带来了什么？\n避免使用「我」「我们」（个人习惯） 尤其在项目文档中，当需要表达自己做了什么事情时，最好不加主语或使用项目名作为主语。\n专有名词中同时包含中英文时，在两侧加空格（个人习惯） 示例：\n我经常使用 QQ音乐 听歌。\n内容 避免对事物作过于主观的判断或情绪化的质疑 正确示例：\n为什么中国互联网的山寨现象比较普遍？而创新很少？\n错误示例：\n为什么中国互联网全是山寨？\n避免在未经确认的事物之上进行推演 也就是「先问是不是，再问为什么」。\n正确示例：\n据说 XX 公司被 XX 收购了，传言是否属实？\n错误示例：\n据说 XX 公司被 XX 收购了，他们为什么要卖掉公司？\n避免任何带有歧视的内容 包括但不限于对民族、种族、宗教信仰、性取向、性别、文化、阶层、职业、年龄等的歧视。\n全文转载需在标题和文章开头注明并给出原文链接，部分引用需在文章末尾以项目列表形式给出引用资料链接 全文转载亦包括翻译。如果不是网络资源（即没有链接），则给出原文标题和出处。\n参考资料 中文文案排版指北 魅族写作手册 豌豆荚文案风格指南 知乎的提问规范有哪些？ 知乎的问题修改规范有哪些？ 省略号 中文数字 标点符号用法 ","date":"2022-06-25","permalink":"https://shudorcl.github.io/post/chinese-writing-style/","tags":["杂物"],"title":"【转载】中文写作风格指南"},{"content":"大概两周前觉得自己需要找个地方表达一些想法，于是决定建一个自己的博客！\n在2202年的当下建博客的资料非常多，我一开始想用zola，但是它主题太少了，于是选择了hugo\n之后的流程非常简单，安装chocolatey，安装hugo，然后照着资料和文档一步步来，就搭好了\n安装chocolatey 一开始因为是要安装zola，发现官网推荐使用chocolatey，否则就只能从源代码构建了，于是就去下载安装chocolatey，按照官网的指引，在管理员模式的PowerShell中输入以下命令进行安装。\nGet-ExecutionPolicy\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n因为是两周前的事情，所以忘了要不要武当梯云纵了。\n安装hugo 这就更简单了，输入choco install hugo -confirm和choco install hugo-extended -confirm进行安装，不过还是得在管理员模式的PowerShell下，真是的，为什么Windows没有sudo。\n2022年7月25日更新：\nWindows Terminal是神，而我当时还没更新，背弃了它的光辉\nQuick Start 直接看官网的Quick Start，就好了。\n我主题选择的是Fuji。\n后面摸了，可以去看官网如何部署到GitHub Pages，或者找几篇文章参考一下，比如说这篇。\n值得注意的一点就是，如果你在部署page的时候选择的基底文件夹是docs，那么可以对config.toml进行如下修改\npublishDir = \u0026quot;./docs\u0026quot;\n这样编译生成的静态网站就可以定位到docs文件夹了。\n部署 2023年2月15日01点06分更新：\n半年多过去了，愈发觉得不能简简单单暴露博客源码，于是重新参考了这篇文章，以及仔细研读了官网的部署方案\n现在公开仓库中只有成品网站，源码转移到了私有仓库中\n（而且也不用每次都手动build了）\n","date":"2022-06-18","permalink":"https://shudorcl.github.io/post/how-to-build-a-blog/","tags":["杂物"],"title":"关于这个博客是怎么搭的这件事"}]