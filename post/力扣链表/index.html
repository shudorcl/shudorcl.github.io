<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.111.3"><link rel=apple-touch-icon sizes=180x180 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-16x16.png><link rel=manifest href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/site.webmanifest><link rel=mask-icon href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/safari-pinned-tab.svg color=#8aa2d3><link rel="shortcut icon" href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon.ico><meta name=theme-color content="#ffffff"><title>力扣链表 - dorcl's Blog</title><meta name=author content="dorcl"><meta name=description content="碎梦残香"><meta name=keywords content="力扣"><meta property="og:title" content="力扣链表"><meta name=twitter:title content="力扣链表"><meta property="og:type" content="article"><meta property="og:url" content="https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A3%E9%93%BE%E8%A1%A8/"><meta property="og:description" content="想了想没必要一道题发一篇，干脆就一章塞一起吧！"><meta name=twitter:description content="想了想没必要一道题发一篇，干脆就一章塞一起吧！"><meta property="og:image" content="https://shudorcl.github.io/img/og.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shudorcl.github.io/img/og.png"><meta property="article:published_time" content="2022-09-23T00:26:27+08:00"><meta property="article:modified_time" content="2022-09-23T00:26:27+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://shudorcl.github.io/assets/css/fuji.min.b4a21b5d3eb1d0a51297e31230a65fc25e387843e45ec3a2d9176cd8d163c216d99b9b13a618b28f537c3b559ec8a408183b0fbfad48daddb9befa7d3ef90eed.css integrity="sha512-tKIbXT6x0KUSl+MSMKZfwl44eEPkXsOi2Rds2NFjwhbZm5sTphiyj1N8O1WeyKQIGDsPv61I2t25vvp9PvkO7Q=="></head><body data-theme=auto data-theme-auto=true><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://shudorcl.github.io>dorcl's Blog</a>
<span class=title-sub>碎梦残香</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A3%E9%93%BE%E8%A1%A8/>力扣链表</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2022-09-23</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;1819 字</span>
<span><i class="iconfont icon-time-sharp"></i>&nbsp;4 分钟</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/%E5%8A%9B%E6%89%A3>力扣</a>&nbsp;</span></div><div class="post-content markdown-body"><p>想了想没必要一道题发一篇，干脆就一章塞一起吧！</p><h2 id=203-remove-linked-list-elements>203. Remove Linked List Elements</h2><h3 id=题目描述>题目描述</h3><p>Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.</p><h3 id=解题思路>解题思路</h3><p>非常简单，只要记录头尾然后乾坤大挪移即可</p><p>说是这么说，但还是处理一些特殊情况需要注意</p><pre><code class=language-go>func removeElements(head *ListNode, val int) *ListNode {
    curr:=head
    // 清理头部
    for curr!=nil&amp;&amp;curr.Val==val{
        curr=curr.Next
    }
    // 如果头部依然为空返回空
    if curr==nil{
        return nil
    }
    nhead := curr
    pre := curr         // 因为头部处理过了放心到下一个
    curr = curr.Next
    for curr!=nil{      // 不能是curr.Next!=nil，会报错
        if curr.Val==val{
            pre.Next=curr.Next
        }else{
            pre=curr
        }
        curr=curr.Next
    }
    return nhead
}
</code></pre><p>好了，我睡了！</p><h2 id=707-design-linked-list>707. Design Linked List</h2><h3 id=题目描述-1>题目描述</h3><p>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.
A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node.
If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p><p>Implement the MyLinkedList class:</p><p>MyLinkedList() Initializes the MyLinkedList object.
int get(int index) Get the value of the indexth node in the linked list. If the index is invalid, return -1.
void addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
void addAtTail(int val) Append a node of value val as the last element of the linked list.
void addAtIndex(int index, int val) Add a node of value val before the indexth node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted.
void deleteAtIndex(int index) Delete the indexth node in the linked list, if the index is valid.</p><p>可笑，学过数据结构就知道这种事情非常简单！</p><h3 id=解题思路-1>解题思路</h3><p>手写链表比较细，没什么需要注意的，不过双链表需要有个哨兵头尾，这点上课的时候好像没学过？</p><h2 id=反转链表>反转链表</h2><h3 id=题目描述-2>题目描述</h3><p><a href=https://leetcode.cn/problems/reverse-linked-list/ target=_blank>206. Reverse Linked List</a></p><blockquote><p>Given the head of a singly linked list, reverse the list, and return the reversed list.</p></blockquote><h3 id=解题思路-2>解题思路</h3><p>非常简单，考虑每一个节点，只要把尾指针指向前个节点即可，这么思考下去，则需要记录前节点</p><pre><code class=language-go>/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
    curr:=head
    var pre *ListNode
    for curr!=nil{
        next:=curr.Next
        curr.Next = pre
        pre = curr
        curr=next
    }
    return pre
}
</code></pre><p>再看看其它解法？</p><p>2022年10月22日</p><p>和舍友讨论，可以把头节点拆出来，然后遍历一个个使用头插法</p><h2 id=两两交换链表中的节点>两两交换链表中的节点</h2><p><a href=https://leetcode.cn/problems/swap-nodes-in-pairs/description/ target=_blank>题目链接</a></p><h3 id=题目描述-3>题目描述</h3><p>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list&rsquo;s nodes (i.e., only nodes themselves may be changed.)</p><h3 id=解题思路-3>解题思路</h3><p>思维好差。。。摸了</p><p>好好好，我恢复了，总之也是比较简单的链表操作，画出图来就能解决</p><p>不过这里学到了一点，可以使用虚拟头节点<code>dummy</code>方便操作，嗯，似乎有点像，双链表的时候的哨兵？</p><pre><code class=language-go>/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func swapPairs(head *ListNode) *ListNode {
    dummy := &amp;ListNode{
        Next: head,
    }
    //head=list[i]
    //pre=list[i-1]
    pre := dummy 
    for head != nil &amp;&amp; head.Next != nil {
        pre.Next = head.Next
        next := head.Next.Next
        head.Next.Next = head
        head.Next = next
        //pre=list[(i+2)-1]
        pre = head 
        //head=list[(i+2)]
        head = next
    }
    return dummy.Next
}
</code></pre><p>就这样吧</p><h2 id=19删除链表的倒数第n个节点>19.删除链表的倒数第N个节点</h2><p><a href=https://leetcode.cn/problems/remove-nth-node-from-end-of-list/ target=_blank>题目地址</a></p><h3 id=题目描述-4>题目描述</h3><p>Given the head of a linked list, remove the nth node from the end of the list and return its head.</p><h3 id=解题思路-4>解题思路</h3><p>什么啊，这一看不是简单至极？</p><p>再看看标签，双指针，原来如此，一次解的思路我已经有了！</p><pre><code class=language-go>/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy:=&amp;ListNode{0,head}
    pre:=dummy
    curr:=head
    pioneer:=head
    // 第一次重定位，前指针先走n步
    for i:=0;i&lt;n;i++{
        pioneer=pioneer.Next
    }
    // 第二次定位，找到删除节点
    for pioneer!=nil{
        pioneer=pioneer.Next
        curr=curr.Next
        pre=pre.Next
    }
    // 删除
    pre.Next=curr.Next
    return dummy.Next
}
</code></pre><p>哼，易如反掌</p><h2 id=0207-intersection-of-two-linked-lists-lcci>02.07. Intersection of Two Linked Lists LCCI</h2><p><a href=https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/ target=_blank>题目链接</a></p><h3 id=题目描述-5>题目描述</h3><p>Given two (singly) linked lists, determine if the two lists intersect. Return the inter­ secting node. Note that the intersection is defined based on reference, not value. That is, if the kth node of the first linked list is the exact same node (by reference) as the jth node of the second linked list, then they are intersecting.</p><h3 id=解题思路-5>解题思路</h3><p>一开始不会做，不过看到图就懂了</p><p><img class=img-zoomable src=https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221657.png alt=原来如此></p><blockquote><p>原来MD图片是要加感叹号啊</p></blockquote><p>显然，只要算出长度差然后一个一个比即可</p><pre><code class=language-go>/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    curr:=headA
    lenA:=0
    lenB:=0
    for curr!=nil{
        lenA++
        curr=curr.Next
    }
    curr=headB
    for curr!=nil{
        lenB++
        curr=curr.Next
    }
    gap:=lenA-lenB
    currA:=headA
    currB:=headB
    if gap&gt;0{
        // A比B长先动A
        for i:=0;i&lt;gap;i++{
            currA=currA.Next
        }
    }else{
        for i:=gap;i&lt;0;i++{
            currB=currB.Next
        }
    }
    for currA!=currB{
        currA=currA.Next
        currB=currB.Next
    }
    return currA
}
</code></pre><h3 id=其他解法>其他解法</h3><p>哈希表，A表入哈希，然后看B表有无</p><pre><code class=language-go>func getIntersectionNode(headA, headB *ListNode) *ListNode {
    vis := map[*ListNode]bool{}
    for tmp := headA; tmp != nil; tmp = tmp.Next {
        vis[tmp] = true
    }
    for tmp := headB; tmp != nil; tmp = tmp.Next {
        if vis[tmp] {
            return tmp
        }
    }
    return nil
}
</code></pre><h2 id=linked-list-cycle-ii>Linked List Cycle II</h2><p><a href=https://leetcode.cn/problems/linked-list-cycle-ii/ target=_blank>题目链接</a></p><h3 id=题目描述-6>题目描述</h3><p>Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&rsquo;s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.</p><p>Do not modify the linked list.</p><h3 id=解题思路-6>解题思路</h3><p>在之前浅看CS61C的时候讲到过一个算法，总之就是双指针一个两步一个一步判断有无环，但是写出来后发现，判断有无环后呢？怎么知道入口？</p><p>于是就去看题解了</p><p>嗯，等量关系。。。不过我饿了先去吃饭</p><p>这一去就是三周。。。</p><p>做点简单的笔记</p><p>我们假设入口距离为<code>x</code>，相遇时在环内走了<code>y</code>，剩余环长为<code>z</code></p><p>相遇的时候，快指针走了<code>x+n*(y+z)</code>步，而慢指针走了<code>x+y</code>步，又有<code>2*(x+y)=x+n*(y+z)</code>，稍微计算一下，就有</p><p><code>x=(n-1)*(y+z)+z</code>，那么若<code>n=1</code>，则有<code>x=z</code>，所以此时只要在第一次相遇点，把快指针挪回初始点，找到他们再度相遇的点，即为入口</p><p>若<code>n!=1</code>呢？那么也是一样处理，只不过慢指针会多绕<code>n-1</code>圈</p><pre><code class=language-go>/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
    fast:=head
    slow:=head
    for fast!=nil&amp;&amp;fast.Next!=nil{   // 判断有无环
        fast=fast.Next.Next
        slow=slow.Next
        if fast==slow{          // 相遇，有环
            fast = head         // 挪回开头寻找
            for fast!=slow{
                fast = fast.Next
                slow = slow.Next
            }
            return fast         // 相遇返回
        }
    }
    return nil
}
</code></pre><p>哟西，链表算是完结了！</p></div></article><div class="license markdown-body"><blockquote><p>除特殊注明部分，本站内容采用 <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a> 进行许可。</p></blockquote></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/mood/>Mood</a></li><li><a href=/friends/>Friends</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/shudorcl target=_blank><span>GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/%E5%8A%9B%E6%89%A3/>力扣</a></span>
<span><a href=/tags/%E6%9D%82%E7%89%A9/>杂物</a></span>
<span><a href=/tags/%E7%AC%94%E8%AE%B0/>笔记</a></span>
<span><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/>计算机</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#203-remove-linked-list-elements>203. Remove Linked List Elements</a><ul><li><a href=#题目描述>题目描述</a></li><li><a href=#解题思路>解题思路</a></li></ul></li><li><a href=#707-design-linked-list>707. Design Linked List</a><ul><li><a href=#题目描述-1>题目描述</a></li><li><a href=#解题思路-1>解题思路</a></li></ul></li><li><a href=#反转链表>反转链表</a><ul><li><a href=#题目描述-2>题目描述</a></li><li><a href=#解题思路-2>解题思路</a></li></ul></li><li><a href=#两两交换链表中的节点>两两交换链表中的节点</a><ul><li><a href=#题目描述-3>题目描述</a></li><li><a href=#解题思路-3>解题思路</a></li></ul></li><li><a href=#19删除链表的倒数第n个节点>19.删除链表的倒数第N个节点</a><ul><li><a href=#题目描述-4>题目描述</a></li><li><a href=#解题思路-4>解题思路</a></li></ul></li><li><a href=#0207-intersection-of-two-linked-lists-lcci>02.07. Intersection of Two Linked Lists LCCI</a><ul><li><a href=#题目描述-5>题目描述</a></li><li><a href=#解题思路-5>解题思路</a></li><li><a href=#其他解法>其他解法</a></li></ul></li><li><a href=#linked-list-cycle-ii>Linked List Cycle II</a><ul><li><a href=#题目描述-6>题目描述</a></li><li><a href=#解题思路-6>解题思路</a></li></ul></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/mood/>Mood</a></li><li><a href=/friends/>Friends</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/shudorcl target=_blank><span>GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/%E5%8A%9B%E6%89%A3/>力扣</a></span>
<span><a href=/tags/%E6%9D%82%E7%89%A9/>杂物</a></span>
<span><a href=/tags/%E7%AC%94%E8%AE%B0/>笔记</a></span>
<span><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/>计算机</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#203-remove-linked-list-elements>203. Remove Linked List Elements</a><ul><li><a href=#题目描述>题目描述</a></li><li><a href=#解题思路>解题思路</a></li></ul></li><li><a href=#707-design-linked-list>707. Design Linked List</a><ul><li><a href=#题目描述-1>题目描述</a></li><li><a href=#解题思路-1>解题思路</a></li></ul></li><li><a href=#反转链表>反转链表</a><ul><li><a href=#题目描述-2>题目描述</a></li><li><a href=#解题思路-2>解题思路</a></li></ul></li><li><a href=#两两交换链表中的节点>两两交换链表中的节点</a><ul><li><a href=#题目描述-3>题目描述</a></li><li><a href=#解题思路-3>解题思路</a></li></ul></li><li><a href=#19删除链表的倒数第n个节点>19.删除链表的倒数第N个节点</a><ul><li><a href=#题目描述-4>题目描述</a></li><li><a href=#解题思路-4>解题思路</a></li></ul></li><li><a href=#0207-intersection-of-two-linked-lists-lcci>02.07. Intersection of Two Linked Lists LCCI</a><ul><li><a href=#题目描述-5>题目描述</a></li><li><a href=#解题思路-5>解题思路</a></li><li><a href=#其他解法>其他解法</a></li></ul></li><li><a href=#linked-list-cycle-ii>Linked List Cycle II</a><ul><li><a href=#题目描述-6>题目描述</a></li><li><a href=#解题思路-6>解题思路</a></li></ul></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2022-2023
<a href=https://shudorcl.github.io>dorcl</a>
| <a href=https://github.com/shudorcl/shudorcl.github.io>Source code</a>
| 基于 <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a> 构建</span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ==" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js integrity="sha512-LCKPTo0gtJ74zCNMbWw04ltmujpzSR4oW+fgN+Y1YclhM5ZrHCZQAJE4quEodcI/G122sRhSGU2BsSRUZ2Gu3w==" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js integrity="sha512-GP4x8UWxWyh4BMbyJGOGneiTbkrWEF5izsVJByzVLodP8CuJH/n936+yQDMJJrOPUHLgyPbLiGw2rXmdvGdXHA==" crossorigin=anonymous></script>
<script defer src=/assets/js/fuji.min.645f1123be695831f419ab54c1bcba327325895c740014006e57070d4f3e5d6b553e929c4b46f40ea707249e9c7f7c2a446d32a39ce7319f80a34525586a8e0f.js integrity="sha512-ZF8RI75pWDH0GatUwby6MnMliVx0ABQAblcHDU8+XWtVPpKcS0b0DqcHJJ6cf3wqRG0yo5znMZ+Ao0UlWGqODw=="></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css integrity="sha512-07YhC3P4/vS5HdgGuNAAeIxb5ee//efgRNo5AGdMtqFBUPYOdQG/sDK0Nl5qNq94kdEk/Pvu8pmN4GYUeucUkw==" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js integrity="sha512-aMDiFsrEV3KzAn9EHwyBRS7y1APjZWt/Z/73ukLN2Ca2KcGGzlOQFQSnfOdnEcehpwMaQ8edlDB/0cMX2GsHbg==" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js integrity="sha512-ZA/RPrAo88DlwRnnoNVqKINnQNcWERzRK03PDaA4GIJiVZvGFIWQbdWCsUebMZfkWohnfngsDjXzU6PokO4jGw==" crossorigin=anonymous></script>
<script>renderMathInElement(document.querySelector("div.content"),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})</script></body></html>