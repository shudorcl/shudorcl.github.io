<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.110.0"><link rel=apple-touch-icon sizes=180x180 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-16x16.png><link rel=manifest href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/site.webmanifest><link rel=mask-icon href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/safari-pinned-tab.svg color=#8aa2d3><link rel="shortcut icon" href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon.ico><meta name=theme-color content="#ffffff"><title>力扣二叉树 - dorcl's Blog</title><meta name=author content="dorcl"><meta name=description content="A minimal Hugo theme with nice theme color."><meta name=keywords content="力扣"><meta property="og:title" content="力扣二叉树"><meta name=twitter:title content="力扣二叉树"><meta property="og:type" content="article"><meta property="og:url" content="https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A3%E4%BA%8C%E5%8F%89%E6%A0%91/"><meta property="og:description" content="摸了几天后继续开始！"><meta name=twitter:description content="摸了几天后继续开始！"><meta property="og:image" content="https://shudorcl.github.io/img/og.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shudorcl.github.io/img/og.png"><meta property="article:published_time" content="2023-02-05T23:37:19+08:00"><meta property="article:modified_time" content="2023-02-05T23:37:19+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://shudorcl.github.io/assets/css/fuji.min.b4a21b5d3eb1d0a51297e31230a65fc25e387843e45ec3a2d9176cd8d163c216d99b9b13a618b28f537c3b559ec8a408183b0fbfad48daddb9befa7d3ef90eed.css integrity="sha512-tKIbXT6x0KUSl+MSMKZfwl44eEPkXsOi2Rds2NFjwhbZm5sTphiyj1N8O1WeyKQIGDsPv61I2t25vvp9PvkO7Q=="></head><body data-theme=auto data-theme-auto=true><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://shudorcl.github.io>dorcl's Blog</a>
<span class=title-sub>To The Unlimited Future...</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A3%E4%BA%8C%E5%8F%89%E6%A0%91/>力扣二叉树</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2023-02-05</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;1015 words</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/%E5%8A%9B%E6%89%A3>力扣</a>&nbsp;</span></div><div class="post-content markdown-body"><p>摸了几天后继续开始！</p><h2 id=二叉树基础知识>二叉树基础知识</h2><h3 id=二叉树的种类>二叉树的种类</h3><ul><li>满二叉树</li><li>完全二叉树</li><li>二叉搜索树</li><li>平衡搜索二叉树</li></ul><h4 id=二叉搜索树>二叉搜索树</h4><p><strong>二叉搜索树</strong>是一个有序树。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p>即：根节点为中值</p><p><strong>平衡二叉搜索树</strong>，它是一棵空树或它的左右两个子树的高度差的绝对值<strong>不超过1</strong>，并且左右两个子树都是一棵平衡二叉树。</p><h3 id=二叉树的遍历>二叉树的遍历</h3><p>主要有两种：</p><ol><li>深度优先</li><li>广度优先</li></ol><p>深度：前中后序遍历</p><p>广度：层次遍历</p><h3 id=二叉树的定义>二叉树的定义</h3><p>Cpp:</p><pre><code class=language-cpp>struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
</code></pre><h2 id=二叉树的递归遍历>二叉树的递归遍历</h2><h3 id=递归的要素>递归的要素</h3><ol><li>确定递归函数的参数和返回值</li><li>确定中止条件</li><li>确定单层递归的逻辑</li></ol><h3 id=144-binary-tree-preorder-traversal>144. Binary Tree Preorder Traversal</h3><p>Cpp：</p><pre><code class=language-cpp>class Solution {
public:
    void truePreorderTraversal(TreeNode* root, vector&lt;int&gt;&amp; result){
        if(root==nullptr)
            return;
        result.push_back(root-&gt;val);
        truePreorderTraversal(root-&gt;left,result);
        truePreorderTraversal(root-&gt;right,result);

    }
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        truePreorderTraversal(root,result);
        return result;
    }
};
</code></pre><p>Go：</p><pre><code class=language-go>func truePreorderTraversal(root *TreeNode, result *[]int){
    // 需要注意的是Go中只有值传递，需要传入指针
    if root==nil{
        return
    }
    *result = append(*result,root.Val)
    truePreorderTraversal(root.Left,result)
    truePreorderTraversal(root.Right,result)
}

func preorderTraversal(root *TreeNode) []int {
    result := []int{}
    truePreorderTraversal(root,&amp;result)
    return result
}
</code></pre><h3 id=145-binary-tree-postorder-traversal>145. Binary Tree Postorder Traversal</h3><p>Go：</p><pre><code class=language-go>func postorderTraversal(root *TreeNode) []int {
    res := []int{}
    var trueTraversal func(root *TreeNode)
    // 也可以定义内建函数
    trueTraversal = func(root *TreeNode){
        if root==nil{
            return
        }
        trueTraversal(root.Left)
        trueTraversal(root.Right)
        res = append(res,root.Val)
    }
    trueTraversal(root)
    return res
}
</code></pre><p>Cpp：</p><pre><code class=language-cpp>class Solution {
public:
    void trueTraversal(TreeNode* root, vector&lt;int&gt;&amp; result){
        if(root==nullptr)
            return;
        trueTraversal(root-&gt;left,result);
        trueTraversal(root-&gt;right,result);
        result.push_back(root-&gt;val);
    }
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        trueTraversal(root,res);
        return res;
    }
};
</code></pre><h3 id=94-binary-tree-inorder-traversal>94. Binary Tree Inorder Traversal</h3><p>Cpp:</p><pre><code class=language-cpp>class Solution {
public:
    void trueInorderTraversal(TreeNode* root, vector&lt;int&gt;&amp; result){
        if(root==nullptr)
            return;
        trueInorderTraversal(root-&gt;left,result);
        result.push_back(root-&gt;val);
        trueInorderTraversal(root-&gt;right,result);
    }
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        trueInorderTraversal(root,result);
        return result;
    }
};
</code></pre><p>Go的话就摸了</p><h2 id=二叉树的迭代遍历>二叉树的迭代遍历</h2><p>我们之前用的都是二叉树的递归遍历，而我们知道，递归是用栈实现的，每次调用都会把函数的局部变量、参数和返回地址入栈。</p><h3 id=前序遍历>前序遍历</h3><p>根节点入栈，然后，循环取头节点出栈，其右左节点入栈，直到栈空</p><h4 id=代码实现>代码实现</h4><p>Cpp:</p><pre><code class=language-cpp>class Solution {
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        stack&lt;TreeNode*&gt; nodeStack;
        vector&lt;int&gt; result;
        if (root == nullptr)
            return result;
        nodeStack.push(root);
        while(!nodeStack.empty()){
            TreeNode* node = nodeStack.top();
            nodeStack.pop();
            result.push_back(node-&gt;val);
            if (node-&gt;right)
                nodeStack.push(node-&gt;right);
            if (node-&gt;left)
                nodeStack.push(node-&gt;left);
        }
        return result;
    }
};
</code></pre><h3 id=中序遍历>中序遍历</h3><p>那么，中序遍历是否能和先序遍历一样简单呢？</p><p>显然，是不行的，因为这样就无法像先序遍历一样，每次都取栈顶元素了</p><p>首先，我们得明确两个操作：</p><ol><li>处理：将元素纳入<code>result</code>数组中</li><li>访问：遍历节点</li></ol><p>之前写的先序遍历代码，先访问和先处理的是同一个节点，所以可以写出相对简洁的代码</p><p>而到了中序遍历，就需要访问和处理顺序就不一样了，需要借用指针来帮助访问节点，栈来处理节点上的元素</p><h4 id=代码实现-1>代码实现</h4><p>Cpp：</p><pre><code class=language-cpp>class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; nodeStack;
        // 借助指针访问节点
        TreeNode* cur = root;
        while (cur!=nullptr||! nodeStack.empty()){
            if (cur!=nullptr){
                // 指针访问节点，直到最底层
                nodeStack.push(cur);
                cur = cur-&gt;left; // 继续访问左节点
            } else {
                cur = nodeStack.top();
                nodeStack.pop();
                result.push_back(cur-&gt;val);
                cur = cur-&gt;right;
            }
        }
        return result;
    }
};
</code></pre><h3 id=后序遍历>后序遍历</h3><p>知道了中序遍历，那么后序遍历就很简单了，只需要对前序遍历稍作修改</p><p>中左右->中右左</p><p>然后，反转result数组，就可以得到左右中</p><h4 id=代码实现-2>代码实现</h4><pre><code class=language-cpp>class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        stack&lt;TreeNode*&gt; nodeStack;
        vector&lt;int&gt; result;
        if (root==nullptr)
            return result;
        nodeStack.push(root);
        while(!nodeStack.empty()){
            TreeNode* node = nodeStack.top();
            nodeStack.pop();
            result.push_back(node-&gt;val);
            if(node-&gt;left)
                nodeStack.push(node-&gt;left);
            if(node-&gt;right)
                nodeStack.push(node-&gt;right);
        }
        reverse(result.begin(),result.end());
        return result;
    }
};
</code></pre></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p></blockquote></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/mood/>Mood</a></li><li><a href=/friends/>Friends</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/shudorcl target=_blank><span>GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/%E5%8A%9B%E6%89%A3/>力扣</a></span>
<span><a href=/tags/%E6%9D%82%E7%89%A9/>杂物</a></span>
<span><a href=/tags/%E7%AC%94%E8%AE%B0/>笔记</a></span>
<span><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/>计算机</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#二叉树基础知识>二叉树基础知识</a><ul><li><a href=#二叉树的种类>二叉树的种类</a></li><li><a href=#二叉树的遍历>二叉树的遍历</a></li><li><a href=#二叉树的定义>二叉树的定义</a></li></ul></li><li><a href=#二叉树的递归遍历>二叉树的递归遍历</a><ul><li><a href=#递归的要素>递归的要素</a></li><li><a href=#144-binary-tree-preorder-traversal>144. Binary Tree Preorder Traversal</a></li><li><a href=#145-binary-tree-postorder-traversal>145. Binary Tree Postorder Traversal</a></li><li><a href=#94-binary-tree-inorder-traversal>94. Binary Tree Inorder Traversal</a></li></ul></li><li><a href=#二叉树的迭代遍历>二叉树的迭代遍历</a><ul><li><a href=#前序遍历>前序遍历</a></li><li><a href=#中序遍历>中序遍历</a></li><li><a href=#后序遍历>后序遍历</a></li></ul></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/mood/>Mood</a></li><li><a href=/friends/>Friends</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/shudorcl target=_blank><span>GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/%E5%8A%9B%E6%89%A3/>力扣</a></span>
<span><a href=/tags/%E6%9D%82%E7%89%A9/>杂物</a></span>
<span><a href=/tags/%E7%AC%94%E8%AE%B0/>笔记</a></span>
<span><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/>计算机</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#二叉树基础知识>二叉树基础知识</a><ul><li><a href=#二叉树的种类>二叉树的种类</a></li><li><a href=#二叉树的遍历>二叉树的遍历</a></li><li><a href=#二叉树的定义>二叉树的定义</a></li></ul></li><li><a href=#二叉树的递归遍历>二叉树的递归遍历</a><ul><li><a href=#递归的要素>递归的要素</a></li><li><a href=#144-binary-tree-preorder-traversal>144. Binary Tree Preorder Traversal</a></li><li><a href=#145-binary-tree-postorder-traversal>145. Binary Tree Postorder Traversal</a></li><li><a href=#94-binary-tree-inorder-traversal>94. Binary Tree Inorder Traversal</a></li></ul></li><li><a href=#二叉树的迭代遍历>二叉树的迭代遍历</a><ul><li><a href=#前序遍历>前序遍历</a></li><li><a href=#中序遍历>中序遍历</a></li><li><a href=#后序遍历>后序遍历</a></li></ul></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2020-2023
<a href=https://shudorcl.github.io>dorcl</a>
| <a href=https://github.com/shudorcl/shudorcl.github.io>Source code</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ==" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js integrity="sha512-LCKPTo0gtJ74zCNMbWw04ltmujpzSR4oW+fgN+Y1YclhM5ZrHCZQAJE4quEodcI/G122sRhSGU2BsSRUZ2Gu3w==" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js integrity="sha512-GP4x8UWxWyh4BMbyJGOGneiTbkrWEF5izsVJByzVLodP8CuJH/n936+yQDMJJrOPUHLgyPbLiGw2rXmdvGdXHA==" crossorigin=anonymous></script>
<script defer src=/assets/js/fuji.min.645f1123be695831f419ab54c1bcba327325895c740014006e57070d4f3e5d6b553e929c4b46f40ea707249e9c7f7c2a446d32a39ce7319f80a34525586a8e0f.js integrity="sha512-ZF8RI75pWDH0GatUwby6MnMliVx0ABQAblcHDU8+XWtVPpKcS0b0DqcHJJ6cf3wqRG0yo5znMZ+Ao0UlWGqODw=="></script></body></html>