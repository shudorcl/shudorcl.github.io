<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.117.0"><link rel=apple-touch-icon sizes=180x180 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-16x16.png><link rel=manifest href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/site.webmanifest><link rel=mask-icon href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/safari-pinned-tab.svg color=#8aa2d3><link rel="shortcut icon" href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon.ico><meta name=theme-color content="#ffffff"><title>力扣二叉树 - dorcl's Blog</title><meta name=author content="dorcl"><meta name=description content="碎梦残香"><meta name=keywords content="力扣"><meta property="og:title" content="力扣二叉树"><meta name=twitter:title content="力扣二叉树"><meta property="og:type" content="article"><meta property="og:url" content="https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A3%E4%BA%8C%E5%8F%89%E6%A0%91/"><meta property="og:description" content="摸了几天后继续开始！"><meta name=twitter:description content="摸了几天后继续开始！"><meta property="og:image" content="https://shudorcl.github.io/img/og.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shudorcl.github.io/img/og.png"><meta property="article:published_time" content="2023-02-05T23:37:19+08:00"><meta property="article:modified_time" content="2023-02-05T23:37:19+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://shudorcl.github.io/assets/css/fuji.min.b4a21b5d3eb1d0a51297e31230a65fc25e387843e45ec3a2d9176cd8d163c216d99b9b13a618b28f537c3b559ec8a408183b0fbfad48daddb9befa7d3ef90eed.css integrity="sha512-tKIbXT6x0KUSl+MSMKZfwl44eEPkXsOi2Rds2NFjwhbZm5sTphiyj1N8O1WeyKQIGDsPv61I2t25vvp9PvkO7Q=="></head><body data-theme=auto data-theme-auto=true><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://shudorcl.github.io>dorcl's Blog</a>
<span class=title-sub>碎梦残香</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A3%E4%BA%8C%E5%8F%89%E6%A0%91/>力扣二叉树</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2023-02-05</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;2106 字</span>
<span><i class="iconfont icon-time-sharp"></i>&nbsp;5 分钟</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/%E5%8A%9B%E6%89%A3>力扣</a>&nbsp;</span></div><div class="post-content markdown-body"><p>摸了几天后继续开始！</p><h2 id=二叉树基础知识>二叉树基础知识</h2><h3 id=二叉树的种类>二叉树的种类</h3><ul><li>满二叉树</li><li>完全二叉树</li><li>二叉搜索树</li><li>平衡搜索二叉树</li></ul><h4 id=二叉搜索树>二叉搜索树</h4><p><strong>二叉搜索树</strong>是一个有序树。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p>即：根节点为中值</p><p><strong>平衡二叉搜索树</strong>，它是一棵空树或它的左右两个子树的高度差的绝对值<strong>不超过1</strong>，并且左右两个子树都是一棵平衡二叉树。</p><h3 id=二叉树的遍历>二叉树的遍历</h3><p>主要有两种：</p><ol><li>深度优先</li><li>广度优先</li></ol><p>深度：前中后序遍历</p><p>广度：层次遍历</p><h3 id=二叉树的定义>二叉树的定义</h3><p>Cpp:</p><pre><code class=language-cpp>struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
</code></pre><h2 id=二叉树的递归遍历>二叉树的递归遍历</h2><h3 id=递归的要素>递归的要素</h3><ol><li>确定递归函数的参数和返回值</li><li>确定中止条件</li><li>确定单层递归的逻辑</li></ol><h3 id=144-binary-tree-preorder-traversal>144. Binary Tree Preorder Traversal</h3><p>Cpp：</p><pre><code class=language-cpp>class Solution {
public:
    void truePreorderTraversal(TreeNode* root, vector&lt;int&gt;&amp; result){
        if(root==nullptr)
            return;
        result.push_back(root-&gt;val);
        truePreorderTraversal(root-&gt;left,result);
        truePreorderTraversal(root-&gt;right,result);

    }
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        truePreorderTraversal(root,result);
        return result;
    }
};
</code></pre><p>Go：</p><pre><code class=language-go>func truePreorderTraversal(root *TreeNode, result *[]int){
    // 需要注意的是Go中只有值传递，需要传入指针
    if root==nil{
        return
    }
    *result = append(*result,root.Val)
    truePreorderTraversal(root.Left,result)
    truePreorderTraversal(root.Right,result)
}

func preorderTraversal(root *TreeNode) []int {
    result := []int{}
    truePreorderTraversal(root,&amp;result)
    return result
}
</code></pre><h3 id=145-binary-tree-postorder-traversal>145. Binary Tree Postorder Traversal</h3><p>Go：</p><pre><code class=language-go>func postorderTraversal(root *TreeNode) []int {
    res := []int{}
    var trueTraversal func(root *TreeNode)
    // 也可以定义内建函数
    trueTraversal = func(root *TreeNode){
        if root==nil{
            return
        }
        trueTraversal(root.Left)
        trueTraversal(root.Right)
        res = append(res,root.Val)
    }
    trueTraversal(root)
    return res
}
</code></pre><p>Cpp：</p><pre><code class=language-cpp>class Solution {
public:
    void trueTraversal(TreeNode* root, vector&lt;int&gt;&amp; result){
        if(root==nullptr)
            return;
        trueTraversal(root-&gt;left,result);
        trueTraversal(root-&gt;right,result);
        result.push_back(root-&gt;val);
    }
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        trueTraversal(root,res);
        return res;
    }
};
</code></pre><h3 id=94-binary-tree-inorder-traversal>94. Binary Tree Inorder Traversal</h3><p>Cpp:</p><pre><code class=language-cpp>class Solution {
public:
    void trueInorderTraversal(TreeNode* root, vector&lt;int&gt;&amp; result){
        if(root==nullptr)
            return;
        trueInorderTraversal(root-&gt;left,result);
        result.push_back(root-&gt;val);
        trueInorderTraversal(root-&gt;right,result);
    }
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        trueInorderTraversal(root,result);
        return result;
    }
};
</code></pre><p>Go的话就摸了</p><h2 id=二叉树的迭代遍历>二叉树的迭代遍历</h2><p>我们之前用的都是二叉树的递归遍历，而我们知道，递归是用栈实现的，每次调用都会把函数的局部变量、参数和返回地址入栈。</p><h3 id=前序遍历>前序遍历</h3><p>根节点入栈，然后，循环取头节点出栈，其右左节点入栈，直到栈空</p><h4 id=前序遍历的代码实现>前序遍历的代码实现</h4><p>Cpp:</p><pre><code class=language-cpp>class Solution {
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        stack&lt;TreeNode*&gt; nodeStack;
        vector&lt;int&gt; result;
        if (root == nullptr)
            return result;
        nodeStack.push(root);
        while(!nodeStack.empty()){
            TreeNode* node = nodeStack.top();
            nodeStack.pop();
            result.push_back(node-&gt;val);
            if (node-&gt;right)
                nodeStack.push(node-&gt;right);
            if (node-&gt;left)
                nodeStack.push(node-&gt;left);
        }
        return result;
    }
};
</code></pre><h3 id=中序遍历>中序遍历</h3><p>那么，中序遍历是否能和先序遍历一样简单呢？</p><p>显然，是不行的，因为这样就无法像先序遍历一样，每次都取栈顶元素了</p><p>首先，我们得明确两个操作：</p><ol><li>处理：将元素纳入<code>result</code>数组中</li><li>访问：遍历节点</li></ol><p>之前写的先序遍历代码，先访问和先处理的是同一个节点，所以可以写出相对简洁的代码</p><p>而到了中序遍历，就需要访问和处理顺序就不一样了，需要借用指针来帮助访问节点，栈来处理节点上的元素</p><h4 id=中序遍历的代码实现>中序遍历的代码实现</h4><p>Cpp：</p><pre><code class=language-cpp>class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; nodeStack;
        // 借助指针访问节点
        TreeNode* cur = root;
        while (cur!=nullptr||! nodeStack.empty()){
            if (cur!=nullptr){
                // 指针访问节点，直到最底层
                nodeStack.push(cur);
                cur = cur-&gt;left; // 继续访问左节点
            } else {
                cur = nodeStack.top();
                nodeStack.pop();
                result.push_back(cur-&gt;val);
                cur = cur-&gt;right;
            }
        }
        return result;
    }
};
</code></pre><h3 id=后序遍历>后序遍历</h3><p>知道了中序遍历，那么后序遍历就很简单了，只需要对前序遍历稍作修改</p><p>中左右->中右左</p><p>然后，反转result数组，就可以得到左右中</p><h4 id=后序遍历的代码实现>后序遍历的代码实现</h4><pre><code class=language-cpp>class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        stack&lt;TreeNode*&gt; nodeStack;
        vector&lt;int&gt; result;
        if (root==nullptr)
            return result;
        nodeStack.push(root);
        while(!nodeStack.empty()){
            TreeNode* node = nodeStack.top();
            nodeStack.pop();
            result.push_back(node-&gt;val);
            if(node-&gt;left)
                nodeStack.push(node-&gt;left);
            if(node-&gt;right)
                nodeStack.push(node-&gt;right);
        }
        reverse(result.begin(),result.end());
        return result;
    }
};
</code></pre><h2 id=二叉树的统一迭代法>二叉树的统一迭代法</h2><p>那么，有没有一种统一的风格解决二叉树的迭代遍历呢？</p><p>是有的</p><p>我们知道，中序遍历时，访问和处理顺序不一样，需要借用指针来帮助访问节点</p><p>可以将访问的节点放进栈中，处理的节点同样入栈，但是需要接着放入空指针作为标记</p><p>这里没意思，先跳</p><h2 id=二叉树的层序遍历>二叉树的层序遍历</h2><p>层序遍历，即从左到右一层层遍历二叉树，需要使用队列来辅助实现</p><p>先进先出，符合一层层遍历的逻辑</p><p>也就是说，这是一种广度优先遍历</p><p>思想非常简单：</p><ol><li>根节点入队</li><li>首节点出队，其左右子节点入队</li><li>如此反复直到队列为空</li></ol><h3 id=102-binary-tree-level-order-traversal>102. Binary Tree Level Order Traversal</h3><p><a href=https://leetcode.cn/problems/binary-tree-level-order-traversal/ target=_blank>题目链接</a></p><p>Given the root of a binary tree, return the level order traversal of its nodes&rsquo; values. (i.e., from left to right, level by level).</p><h4 id=循环法>循环法</h4><pre><code class=language-cpp>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        queue&lt;TreeNode*&gt; que;
        // 根非空加入队列
        if(root!=nullptr)
            que.push(root);
        vector&lt;vector&lt;int&gt;&gt; result;
        // 循环至队空
        while (!que.empty()){
            int size = que.size();
            vector&lt;int&gt; layer;
            for(int i=0;i&lt;size;i++){
                // 头节点出队
                TreeNode* node = que.front();
                que.pop();
                // 处理头节点
                layer.push_back(node-&gt;val);
                if(node-&gt;left)
                    que.push(node-&gt;left);
                if(node-&gt;right)
                    que.push(node-&gt;right);
            }
            result.push_back(layer);
        }
        return result;
    }
};
</code></pre><h4 id=递归法>递归法</h4><pre><code class=language-cpp>Solution {
public:
    void order(TreeNode* cur,vector&lt;vector&lt;int&gt;&gt;&amp; result, int depth){
        if(cur==nullptr)
            return;
        if(result.size()==depth)
            // size达到深度扩容
            result.push_back(vector&lt;int&gt;());
        result[depth].push_back(cur-&gt;val);
        order(cur-&gt;left,result,depth+1);
        order(cur-&gt;right,result,depth+1);
    }
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; result;
        int depth = 0;
        order(root,result,depth);
        return result;
    }
};
</code></pre><h2 id=226-invert-binary-tree>226. Invert Binary Tree</h2><p>又是一道有梗的题目</p><p>Given the root of a binary tree, invert the tree, and return its root.</p><p>怎么做呢？</p><p>其实很简单，把所有节点的左右子节点交换一下就好了</p><p>不过，值得注意的是，中序遍历会交换两次</p><pre><code class=language-cpp>class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==nullptr)
            return root;
        swap(root-&gt;left,root-&gt;right);
        invertTree(root-&gt;left);
        invertTree(root-&gt;right);
        return root;
    }
};
</code></pre><pre><code class=language-go>func invertTree(root *TreeNode) *TreeNode {
    if root==nil{
        return root
    }
    root.Left,root.Right = root.Right,root.Left
    invertTree(root.Left)
    invertTree(root.Right)
    return root
}
</code></pre><p>看来那个被谷歌拒的大神应该是根本没准备算法题</p><h2 id=101-symmetric-tree>101. Symmetric Tree</h2><p>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</p><h3 id=101思路>101.思路</h3><p>嗯哼，层序遍历然后看对不对称是吧？</p><p>不，并不行，需要是<strong>镜像</strong>对称的，详见样例</p><p>我们需要比较二叉树的“里侧”和“外侧”是不是相同，也就是，以不同的顺序遍历根节点的左右子节点</p><p>遍历顺序的都是后序遍历，即：左节点左右中，右节点右左中</p><p>为什么是后序呢？</p><p>因为需要先判断子节点，然后再返回上一级节点</p><p>好吧，其实我在这里也是一知半解，先看看代码吧</p><h3 id=101代码实现>101.代码实现</h3><pre><code class=language-cpp>class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right){
        // 判断是否为空
        if(left==nullptr&amp;&amp;right==nullptr)
            return true;
        if((left==nullptr&amp;&amp;right!=nullptr)||(left!=nullptr&amp;&amp;right==nullptr))
            return false;
        // 判断值
        if(left-&gt;val!=right-&gt;val)
            return false;
        // 进入下一层
        return compare(left-&gt;left,right-&gt;right)&amp;&amp;compare(left-&gt;right,right-&gt;left);
    }
    bool isSymmetric(TreeNode* root) {
        if(root==nullptr)
            return true;
        return compare(root-&gt;left,root-&gt;right);
    }
};
</code></pre><p>同样地，也可以使用迭代法，但是需要用到队列</p><pre><code class=language-cpp>class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root==nullptr)
            return true;
        queue&lt;TreeNode*&gt; que;
        que.push(root-&gt;left);
        que.push(root-&gt;right);
        while(!que.empty()){
            TreeNode* leftNode = que.front();
            que.pop();
            TreeNode* rightNode = que.front();
            que.pop();
            // 同时为空，说明对称
            if(leftNode==nullptr&amp;&amp;rightNode==nullptr)
                continue;
            // 若不同返回
            if((leftNode==nullptr&amp;&amp;rightNode!=nullptr)||(leftNode!=nullptr&amp;&amp;rightNode==nullptr))
                return false;
            if(leftNode-&gt;val!=rightNode-&gt;val)
                return false;
            // 入队左右子节点
            que.push(leftNode-&gt;left);
            que.push(rightNode-&gt;right);
            que.push(leftNode-&gt;right);
            que.push(rightNode-&gt;left);
        }
        return true;
    }
};
</code></pre><p>嗯，这里的<code>queue</code>换成<code>stack</code>其实也行</p><h2 id=104-maximum-depth-of-binary-tree>104. Maximum Depth of Binary Tree</h2><p>这真的不是遍历的时候带一个层数吗？</p><pre><code class=language-cpp>class Solution {
public:
    int maxdepth = 0;
    void traversal(TreeNode* root,int currDepth){
        if(root==nullptr)
            return;
        if (currDepth&gt;maxdepth){
            maxdepth = currDepth;
        }
        traversal(root-&gt;left,currDepth+1);
        traversal(root-&gt;right,currDepth+1);
    }
    int maxDepth(TreeNode* root) {
        traversal(root,1);
        return maxdepth;
    }
};
</code></pre><p>Note: 还可以层序遍历</p><p>// 又有三周没动了，我这个自制力……</p><p>层序遍历</p><pre><code class=language-cpp>class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr)
            return 0;
        int depth = 0;
        queue&lt;TreeNode*&gt; que;
        que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth++;
            for(int i=0;i&lt;size;i++){
                TreeNode* node = que.front();
                que.pop();
                if(node-&gt;left)
                    que.push(node-&gt;left);
                if(node-&gt;right)
                    que.push(node-&gt;right);
            }
        }
        return depth;
    }
};
</code></pre><h2 id=111-minimum-depth-of-binary-tree>111. Minimum Depth of Binary Tree</h2><p>感觉也可以层序遍历</p><pre><code class=language-cpp>class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root==nullptr)
            return 0;
        queue&lt;TreeNode*&gt; que;
        int depth = 0;
        que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth++;
            for(int i=0;i&lt;size;++i){
                TreeNode* node = que.front();
                que.pop();
                if(node-&gt;left)
                    que.push(node-&gt;left);
                if(node-&gt;right)
                    que.push(node-&gt;right);
                // 左右皆空，返回
                if(!node-&gt;left&amp;&amp;!node-&gt;right)
                    return depth;
            }
        }
        return depth;
    }
};
</code></pre><p>那么递归呢？</p><p>噢，和前面一样，左右皆空返回深度就好</p></div></article><div class="license markdown-body"><blockquote><p>除特殊注明部分，本站内容采用 <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a> 进行许可。</p></blockquote></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/mood/>Mood</a></li><li><a href=/friends/>Friends</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/shudorcl target=_blank><span>GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/%E5%8A%9B%E6%89%A3/>力扣</a></span>
<span><a href=/tags/%E6%9D%82%E7%89%A9/>杂物</a></span>
<span><a href=/tags/%E7%AC%94%E8%AE%B0/>笔记</a></span>
<span><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/>计算机</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#二叉树基础知识>二叉树基础知识</a><ul><li><a href=#二叉树的种类>二叉树的种类</a></li><li><a href=#二叉树的遍历>二叉树的遍历</a></li><li><a href=#二叉树的定义>二叉树的定义</a></li></ul></li><li><a href=#二叉树的递归遍历>二叉树的递归遍历</a><ul><li><a href=#递归的要素>递归的要素</a></li><li><a href=#144-binary-tree-preorder-traversal>144. Binary Tree Preorder Traversal</a></li><li><a href=#145-binary-tree-postorder-traversal>145. Binary Tree Postorder Traversal</a></li><li><a href=#94-binary-tree-inorder-traversal>94. Binary Tree Inorder Traversal</a></li></ul></li><li><a href=#二叉树的迭代遍历>二叉树的迭代遍历</a><ul><li><a href=#前序遍历>前序遍历</a></li><li><a href=#中序遍历>中序遍历</a></li><li><a href=#后序遍历>后序遍历</a></li></ul></li><li><a href=#二叉树的统一迭代法>二叉树的统一迭代法</a></li><li><a href=#二叉树的层序遍历>二叉树的层序遍历</a><ul><li><a href=#102-binary-tree-level-order-traversal>102. Binary Tree Level Order Traversal</a></li></ul></li><li><a href=#226-invert-binary-tree>226. Invert Binary Tree</a></li><li><a href=#101-symmetric-tree>101. Symmetric Tree</a><ul><li><a href=#101思路>101.思路</a></li><li><a href=#101代码实现>101.代码实现</a></li></ul></li><li><a href=#104-maximum-depth-of-binary-tree>104. Maximum Depth of Binary Tree</a></li><li><a href=#111-minimum-depth-of-binary-tree>111. Minimum Depth of Binary Tree</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/mood/>Mood</a></li><li><a href=/friends/>Friends</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/shudorcl target=_blank><span>GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/%E5%8A%9B%E6%89%A3/>力扣</a></span>
<span><a href=/tags/%E6%9D%82%E7%89%A9/>杂物</a></span>
<span><a href=/tags/%E7%AC%94%E8%AE%B0/>笔记</a></span>
<span><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/>计算机</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#二叉树基础知识>二叉树基础知识</a><ul><li><a href=#二叉树的种类>二叉树的种类</a></li><li><a href=#二叉树的遍历>二叉树的遍历</a></li><li><a href=#二叉树的定义>二叉树的定义</a></li></ul></li><li><a href=#二叉树的递归遍历>二叉树的递归遍历</a><ul><li><a href=#递归的要素>递归的要素</a></li><li><a href=#144-binary-tree-preorder-traversal>144. Binary Tree Preorder Traversal</a></li><li><a href=#145-binary-tree-postorder-traversal>145. Binary Tree Postorder Traversal</a></li><li><a href=#94-binary-tree-inorder-traversal>94. Binary Tree Inorder Traversal</a></li></ul></li><li><a href=#二叉树的迭代遍历>二叉树的迭代遍历</a><ul><li><a href=#前序遍历>前序遍历</a></li><li><a href=#中序遍历>中序遍历</a></li><li><a href=#后序遍历>后序遍历</a></li></ul></li><li><a href=#二叉树的统一迭代法>二叉树的统一迭代法</a></li><li><a href=#二叉树的层序遍历>二叉树的层序遍历</a><ul><li><a href=#102-binary-tree-level-order-traversal>102. Binary Tree Level Order Traversal</a></li></ul></li><li><a href=#226-invert-binary-tree>226. Invert Binary Tree</a></li><li><a href=#101-symmetric-tree>101. Symmetric Tree</a><ul><li><a href=#101思路>101.思路</a></li><li><a href=#101代码实现>101.代码实现</a></li></ul></li><li><a href=#104-maximum-depth-of-binary-tree>104. Maximum Depth of Binary Tree</a></li><li><a href=#111-minimum-depth-of-binary-tree>111. Minimum Depth of Binary Tree</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2022-2023
<a href=https://shudorcl.github.io>dorcl</a>
| <a href=https://github.com/shudorcl/shudorcl.github.io>Source code</a>
| 基于 <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a> 构建</span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ==" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js integrity="sha512-LCKPTo0gtJ74zCNMbWw04ltmujpzSR4oW+fgN+Y1YclhM5ZrHCZQAJE4quEodcI/G122sRhSGU2BsSRUZ2Gu3w==" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js integrity="sha512-GP4x8UWxWyh4BMbyJGOGneiTbkrWEF5izsVJByzVLodP8CuJH/n936+yQDMJJrOPUHLgyPbLiGw2rXmdvGdXHA==" crossorigin=anonymous></script>
<script defer src=/assets/js/fuji.min.645f1123be695831f419ab54c1bcba327325895c740014006e57070d4f3e5d6b553e929c4b46f40ea707249e9c7f7c2a446d32a39ce7319f80a34525586a8e0f.js integrity="sha512-ZF8RI75pWDH0GatUwby6MnMliVx0ABQAblcHDU8+XWtVPpKcS0b0DqcHJJ6cf3wqRG0yo5znMZ+Ao0UlWGqODw=="></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css integrity="sha512-07YhC3P4/vS5HdgGuNAAeIxb5ee//efgRNo5AGdMtqFBUPYOdQG/sDK0Nl5qNq94kdEk/Pvu8pmN4GYUeucUkw==" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js integrity="sha512-aMDiFsrEV3KzAn9EHwyBRS7y1APjZWt/Z/73ukLN2Ca2KcGGzlOQFQSnfOdnEcehpwMaQ8edlDB/0cMX2GsHbg==" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js integrity="sha512-ZA/RPrAo88DlwRnnoNVqKINnQNcWERzRK03PDaA4GIJiVZvGFIWQbdWCsUebMZfkWohnfngsDjXzU6PokO4jGw==" crossorigin=anonymous></script>
<script>renderMathInElement(document.querySelector("div.content"),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})</script></body></html>