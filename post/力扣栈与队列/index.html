<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.111.1"><link rel=apple-touch-icon sizes=180x180 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-16x16.png><link rel=manifest href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/site.webmanifest><link rel=mask-icon href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/safari-pinned-tab.svg color=#8aa2d3><link rel="shortcut icon" href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon.ico><meta name=theme-color content="#ffffff"><title>力扣栈与队列 - dorcl's Blog</title><meta name=author content="dorcl"><meta name=description content="A minimal Hugo theme with nice theme color."><meta name=keywords content="力扣"><meta property="og:title" content="力扣栈与队列"><meta name=twitter:title content="力扣栈与队列"><meta property="og:type" content="article"><meta property="og:url" content="https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A3%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"><meta property="og:description" content="嘟嘟嘟，看看这次进展能不能快一点"><meta name=twitter:description content="嘟嘟嘟，看看这次进展能不能快一点"><meta property="og:image" content="https://shudorcl.github.io/img/og.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shudorcl.github.io/img/og.png"><meta property="article:published_time" content="2023-01-23T13:48:22+08:00"><meta property="article:modified_time" content="2023-01-23T13:48:22+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://shudorcl.github.io/assets/css/fuji.min.b4a21b5d3eb1d0a51297e31230a65fc25e387843e45ec3a2d9176cd8d163c216d99b9b13a618b28f537c3b559ec8a408183b0fbfad48daddb9befa7d3ef90eed.css integrity="sha512-tKIbXT6x0KUSl+MSMKZfwl44eEPkXsOi2Rds2NFjwhbZm5sTphiyj1N8O1WeyKQIGDsPv61I2t25vvp9PvkO7Q=="></head><body data-theme=auto data-theme-auto=true><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://shudorcl.github.io>dorcl's Blog</a>
<span class=title-sub>To The Unlimited Future...</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A3%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/>力扣栈与队列</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2023-01-23</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;3265 字</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/%E5%8A%9B%E6%89%A3>力扣</a>&nbsp;</span></div><div class="post-content markdown-body"><p>嘟嘟嘟，看看这次进展能不能快一点</p><p>栈和队列，学过数据结构肯定记得是怎么样的，就不多讲了……</p><h2 id=232implement-queue-using-stacks>232.Implement Queue using Stacks</h2><h3 id=1题目描述>1.题目描述</h3><p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).</p><p>Implement the MyQueue class:</p><p>void push(int x) Pushes element x to the back of the queue.
int pop() Removes the element from the front of the queue and returns it.
int peek() Returns the element at the front of the queue.
boolean empty() Returns true if the queue is empty, false otherwise.</p><h3 id=1解题思路>1.解题思路</h3><p>上数据结构的时候我做过！</p><p>一个栈作为输入，一个栈作为输出就好了！</p><p>就这样，我们轻松地写出了结构体和入队！</p><pre><code class=language-go>type MyQueue struct {
    inStack []int
    outStack []int
}


func Constructor() MyQueue {
    return MyQueue{}
}


func (this *MyQueue) Push(x int)  {
    this.inStack = append(this.inStack,x)
}
</code></pre><p>可是，怎么出队呢？(ﾟ∀。)</p><p>（看了看解析后）原来如此，这两个栈合起来是一个队列</p><p>所以，当我们需要出队的时候，需要一个<code>in2out</code>函数将这些输入栈里面<strong>全部</strong>的内容加入到输出栈里面</p><p>准确地说，是将输入栈里面的内容一个个弹出，再一个个加入输出栈</p><p>噗，实现的时候直接把切片append过去了，这是不符合栈的要求的，而且结果也不对</p><h3 id=1代码实现>1.代码实现</h3><p>Go:</p><pre><code class=language-go>type MyQueue struct {
    // Go结构体声明就好了 
    inStack []int
    outStack []int
}


func Constructor() MyQueue {
    return MyQueue{}
}


func (this *MyQueue) Push(x int)  {
    this.inStack = append(this.inStack,x)
}

func (this *MyQueue) in2out()  {
    for len(this.inStack)&gt;0{
        // 将输入栈内容弹出，加入到输出栈
        this.outStack = append(this.outStack,this.inStack[len(this.inStack)-1])
        // 缩小输入栈
        this.inStack = this.inStack[:len(this.inStack)-1]
    }
}

func (this *MyQueue) Pop() int {
    if len(this.outStack)==0{
        // 只有输出栈为空时才转移
        this.in2out()
    }
    res := this.outStack[len(this.outStack)-1]
    this.outStack = this.outStack[:len(this.outStack)-1]
    return res
}


func (this *MyQueue) Peek() int {
    res := this.Pop()
    // 复用Pop()
    this.outStack = append(this.outStack,res)
    return res
}


func (this *MyQueue) Empty() bool {
    if len(this.inStack) == 0&amp;&amp;len(this.outStack) == 0{
        return true
    }
    return false
}


/**
 * Your MyQueue object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(x);
 * param_2 := obj.Pop();
 * param_3 := obj.Peek();
 * param_4 := obj.Empty();
 */
</code></pre><p>Cpp:</p><p>只是敲一遍熟悉语法……</p><pre><code class=language-cpp>class MyQueue {
public:
    stack&lt;int&gt; inStack;
    stack&lt;int&gt; outStack;
    MyQueue() {

    }
    
    void push(int x) {
        inStack.push(x);
    }
    
    int pop() {
        if(outStack.empty()){
            while(!inStack.empty()){
                outStack.push(inStack.top());
                inStack.pop();
            }
        }
        int res = outStack.top();
        outStack.pop();
        return res;
    }
    
    int peek() {
        int res = this-&gt;pop();
        // 只能用箭头吗……？
        outStack.push(res);
        return res;
    }
    
    bool empty() {
        return outStack.empty()&amp;&amp;inStack.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj-&gt;push(x);
 * int param_2 = obj-&gt;pop();
 * int param_3 = obj-&gt;peek();
 * bool param_4 = obj-&gt;empty();
 */
</code></pre><h2 id=225-implement-stack-using-queues>225. Implement Stack using Queues</h2><h3 id=2题目描述>2.题目描述</h3><p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).</p><p>Implement the MyStack class:</p><p>void push(int x) Pushes element x to the top of the stack.
int pop() Removes the element on the top of the stack and returns it.
int top() Returns the element on the top of the stack.
boolean empty() Returns true if the stack is empty, false otherwise.</p><h3 id=2解题思路>2.解题思路</h3><p>坏了，不知道</p><p>好的，我知道了，用两个队列，一个拿来存储，一个出栈的时候存储转移前面几个</p><h3 id=2代码实现>2.代码实现</h3><pre><code class=language-go>func (this *MyStack) Pop() int {
    res := 0
    // 逐个出队入temp队列
    for len(this.stackQueue)&gt;1{
        this.tempQueue = append(this.tempQueue,this.stackQueue[0])
        this.stackQueue=this.stackQueue[1:]
    }
    // pop最后一个
    res = this.stackQueue[0]
    this.stackQueue = make([]int,len(this.tempQueue))
    // 然后tempQueue再倒回来
    for len(this.stackQueue)&gt;0{
        this.tempQueue = append(this.tempQueue,this.stackQueue[0])
        this.stackQueue=this.tempQueue[1:]
    }
    return res
}
</code></pre><p>似乎<code>for len(this.stackQueue)>0</code>这里不太行……</p><p>噢，可以用一个size来判断</p><p>Go:</p><pre><code class=language-go>type MyStack struct {
   stackQueue []int
   tempQueue []int 
}


func Constructor() MyStack {
   return MyStack{}
}


func (this *MyStack) Push(x int)  {
   this.stackQueue = append(this.stackQueue,x)
}


func (this *MyStack) Pop() int {
   res := 0
   // 逐个出队入temp队列
   for len(this.stackQueue)&gt;1{
       this.tempQueue = append(this.tempQueue,this.stackQueue[0])
       this.stackQueue=this.stackQueue[1:]
   }
   // pop最后一个
   res = this.stackQueue[0]
   this.stackQueue = this.stackQueue[1:]
   // 然后tempQueue再倒回来
   for size:=len(this.tempQueue);size&gt;0;size--{
       this.stackQueue = append(this.stackQueue,this.tempQueue[0])
       this.tempQueue=this.tempQueue[1:]
   }
   return res
}


func (this *MyStack) Top() int {
   return this.stackQueue[len(this.stackQueue)-1]
}


func (this *MyStack) Empty() bool {
   if len(this.stackQueue)==0{
       return true
   }
   return false
}


/**
* Your MyStack object will be instantiated and called as such:
* obj := Constructor();
* obj.Push(x);
* param_2 := obj.Pop();
* param_3 := obj.Top();
* param_4 := obj.Empty();
*/
</code></pre><p>Cpp:</p><pre><code class=language-cpp>class MyStack {
   queue&lt;int&gt; stackQueue;
   queue&lt;int&gt; tempQueue;
public:
   MyStack() {
       return ;
   }
   
   void push(int x) {
       stackQueue.push(x);
   }
   
   int pop() {
       for(int size=stackQueue.size();size&gt;1;--size){
           tempQueue.push(stackQueue.front());
           stackQueue.pop();
       }
       int res = stackQueue.front();
       stackQueue.pop();
       while(!tempQueue.empty()){
           stackQueue.push(tempQueue.front());
           tempQueue.pop();
       }
       return res;
   }
   
   int top() {
       return stackQueue.back();
   }
   
   bool empty() {
       return stackQueue.empty();
   }
};

/**
* Your MyStack object will be instantiated and called as such:
* MyStack* obj = new MyStack();
* obj-&gt;push(x);
* int param_2 = obj-&gt;pop();
* int param_3 = obj-&gt;top();
* bool param_4 = obj-&gt;empty();
*/
</code></pre><h3 id=一个队列的解法>一个队列的解法</h3><p>什么，还能这样！</p><p>思路就是，pop的时候把前面的塞到队尾</p><p>草草草</p><p>Go：</p><pre><code class=language-go>func (this *MyStack) Pop() int {
   res := 0
   // 逐个出队入队尾
   for size:=len(this.stackQueue);size&gt;1;size--{
       this.stackQueue = append(this.stackQueue,this.stackQueue[0])
       this.stackQueue=this.stackQueue[1:]
   }
   // pop最后一个
   res = this.stackQueue[0]
   this.stackQueue = this.stackQueue[1:]
   return res
}
</code></pre><p>Cpp：</p><pre><code class=language-cpp>   int pop() {
       for(int size=stackQueue.size();size&gt;1;--size){
           stackQueue.push(stackQueue.front());
           stackQueue.pop();
       }
       int res = stackQueue.front();
       stackQueue.pop();
       return res;
   }
</code></pre><h2 id=20-valid-parentheses>20. Valid Parentheses</h2><h3 id=3题目描述>3.题目描述</h3><p>Given a string s containing just the characters &lsquo;(&rsquo;, &lsquo;)&rsquo;, &lsquo;{&rsquo;, &lsquo;}&rsquo;, &lsquo;[&rsquo; and &lsquo;]&rsquo;, determine if the input string is valid.</p><p>An input string is valid if:</p><p>Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.</p><h3 id=3解题思路>3.解题思路</h3><p>这题我会！遍历字符串统计数量就好了！</p><pre><code class=language-python>class Solution:
    def isValid(self, s: str) -&gt; bool:
        count1,count2,count3 = 0,0,0
        for i in s:
            if i == '(':
                count1+=1
            if i == '[':
                count2+=1
            if i == '{':
                count3+=1
            if i == ')':
                count1-=1
            if i == ']':
                count2-=1
            if i == '}':
                count3-=1
            if count1&gt;1 or count1&lt;-1:
                return False
            if count2&gt;1 or count2&lt;-1:
                return False
            if count3&gt;1 or count3&lt;-1:
                return False
        if count1==0 and count2 == 0 and count3 == 0:
            return True
        return False
</code></pre><p>然而卡在了<code>"([)]"</code>，而且也不符合大标题栈，那就摸了</p><p>首先，我们得分析一下有哪些不匹配的情况：</p><ol><li>字符串里左方向的括号多余了，如<code>"(([{}])"</code></li><li>字符串里右方向的括号多余了，如<code>"([{}]))"</code></li><li>括号没有多余，但是括号的类型没有匹配上，如<code>"([)]"</code></li></ol><h3 id=3代码实现>3.代码实现</h3><p>值得注意的是，这里匹配左括号，但是是对应的右括号入栈，这样方便比较</p><p>Cpp：</p><pre><code class=language-cpp>class Solution {
public:
    bool isValid(string s) {
        if (s.size()%2!=0)
            return false;
        stack&lt;char&gt; parenthesesStack;
        for (auto i : s){
            if(i=='(')
                parenthesesStack.push(')');
            else if (i=='[')
                parenthesesStack.push(']');
            else if (i=='{')
                parenthesesStack.push('}');
            // 如果栈为空（单独右括号）或者直接对不上，则说明无法匹配
            else if (parenthesesStack.empty()||parenthesesStack.top()!=i)
                return false;
            // 右括号匹配成功，出栈
            else
                parenthesesStack.pop();
        }
        return parenthesesStack.empty();
    }
};
</code></pre><p>Go：</p><p>复制粘贴的，更妙一点，用了Map省了很多if</p><pre><code class=language-go>func isValid(s string) bool {
    hash := map[byte]byte{')':'(', ']':'[', '}':'{'}
    stack := make([]byte, 0)
    if s == &quot;&quot; {
        return true
    }

    for i := 0; i &lt; len(s); i++ {
        if s[i] == '(' || s[i] == '[' || s[i] == '{' {
            stack = append(stack, s[i])
        } else if len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1] == hash[s[i]] {
            stack = stack[:len(stack)-1]
        } else {
            return false
        }
    }
    return len(stack) == 0
}
</code></pre><h2 id=1047-remove-all-adjacent-duplicates-in-string>1047. Remove All Adjacent Duplicates In String</h2><h3 id=4题目描述>4.题目描述</h3><p>You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.</p><p>We repeatedly make duplicate removals on s until we no longer can.</p><p>Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.</p><h3 id=4解题思路>4.解题思路</h3><p>想到了，跟上一题一样，将字符串一个个入栈，如果将入栈的字符和栈顶一致，就消掉</p><h3 id=4代码实现>4.代码实现</h3><pre><code class=language-cpp>class Solution {
public:
    string removeDuplicates(string s) {
        stack&lt;char&gt; charStack;
        for (auto c:s){
            if (charStack.top()==c){
                charStack.pop();
            }
            else{
                charStack.push(c);
            }
        }
        string res = &quot;&quot;;
        while(!charStack.empty()){
            res+=charStack.top();
            charStack.pop();
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
</code></pre><p>但是这样报了<code>AddressSanitizer:DEADLYSIGNAL</code>，猜测应该是空的stack不能top</p><p>很好，通过了</p><pre><code class=language-cpp>class Solution {
public:
    string removeDuplicates(string s) {
        stack&lt;char&gt; charStack;
        for (auto c:s){
            if(charStack.empty()||charStack.top()!=c){
                charStack.push(c);
            }
            else{
                charStack.pop();
            }
        }
        string res = &quot;&quot;;
        while(!charStack.empty()){
            res+=charStack.top();
            charStack.pop();
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
</code></pre><p>此外，还可以直接把结果字符串作为栈使用</p><pre><code class=language-cpp>class Solution {
public:
    string removeDuplicates(string s) {
        string res = &quot;&quot;;
        for (auto c:s){
            if(res.empty()||res.back()!=c){
                res+=c;
            }
            else{
                res.pop_back();
            }
        }
        return res;
    }
};
</code></pre><p>Go:</p><pre><code class=language-go>func removeDuplicates(s string) string {
    var res []byte
    for i:=0;i&lt;len(s);i++{
        if len(res)&gt;0&amp;&amp;res[len(res)-1]==s[i]{
            res = res[:len(res)-1]
        }else{
            res = append(res,s[i])
        }
    }
    return string(res)
}
</code></pre><h2 id=150-evaluate-reverse-polish-notation>150. Evaluate Reverse Polish Notation</h2><h3 id=5题目描述>5.题目描述</h3><p>You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.</p><p>Evaluate the expression. Return an integer that represents the value of the expression.</p><p>所谓逆波兰表达式就是像序列<code>["2","1","+","3","*"]</code>这样的表达式</p><h3 id=5解题思路>5.解题思路</h3><p>非常简单，读数字就入栈，然后读到符号就取两个运算，再把结果入栈</p><p>不过得注意，先出栈的是第二个操作数</p><h3 id=5代码实现>5.代码实现</h3><p>Python:</p><pre><code class=language-python>class Solution:
    operatorMap = {'+':add,'-':sub,'*':mul,'/':lambda x, y: int(x / y)}
    def evalRPN(self, tokens: List[str]) -&gt; int:
        eval_stack = []
        for i in tokens:
            if i in &quot;+-*/&quot;:
                op2 = eval_stack.pop()
                op1 = eval_stack.pop()
                eval_stack.append(self.operatorMap[i](op1,op2))
            else:
                eval_stack.append(int(i))
        return eval_stack.pop()
</code></pre><p>Cpp:</p><pre><code class=language-cpp>class Solution {
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) {
        stack&lt;long long&gt; evalStack;
        for(int i=0;i&lt;tokens.size();++i){
            if (tokens[i] == &quot;+&quot; || tokens[i] == &quot;-&quot; || tokens[i] == &quot;*&quot; || tokens[i] == &quot;/&quot;){
                long long op2 = evalStack.top();
                evalStack.pop();
                long long op1 = evalStack.top();
                evalStack.pop();
                switch (tokens[i][0]){
                    case '+':
                        evalStack.push(op1+op2);
                        break;
                    case '-':
                        evalStack.push(op1-op2);
                        break;
                    case '*':
                        evalStack.push(op1*op2);
                        break;
                    case '/':
                        evalStack.push(op1/op2);
                        break;
                }
            }else{
                evalStack.push(stoll(tokens[i]));
            }
        }
        return evalStack.top();
    }
};
</code></pre><h2 id=239-sliding-window-maximum>239. Sliding Window Maximum</h2><p>噢噢噢，第一道Hard</p><h3 id=6题目描述>6.题目描述</h3><p>You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p><h3 id=6解题思路>6.解题思路</h3><p>朴素的想法就是在这个范围内一次次找……</p><pre><code class=language-python>class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:
        res = []
        for i in range(0,len(nums)-k+1):
            res.append(max(nums[i:i+k]))
        return res
</code></pre><p>不过这样肯定TLE了</p><p>样例有长达<strong>50000</strong>的滑动窗口，是真的狠……</p><p>那肯定是不会做的，所以看视频了</p><p>这个滑动窗口扩大的过程，就像是一个队列，如果这个队列能够维护一个最大值，就方便了</p><p>那怎么做呢？</p><p>优先队列，堆……好吧只知道名字</p><p>但是它们不行，因为会自动改顺序，不能pop出离开窗口的内容</p><p>于是就需要单调队列</p><p>在入队的时候，弹掉前面比它小的元素，这样最大值就一定在队首</p><h3 id=6代码实现>6.代码实现</h3><p>Cpp：</p><pre><code class=language-cpp>class Solution {
private:
    class MyQueue{
    public:
        deque&lt;int&gt; que;
        void pop(int value){
            // 查空比照数值
            if(!que.empty()&amp;&amp;que.front()==value){
                que.pop_front();
            }
        }
        void push(int value){
            // 从队尾开始排除小于value的值
            while(!que.empty()&amp;&amp;que.back()&lt;value){
                que.pop_back();
            }
            // 插入
            que.push_back(value);
        }
        int front(){
            return que.front();
        }
    };
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {
        MyQueue que;
        vector&lt;int&gt; res;
        for(int i=0;i&lt;k;++i){
            que.push(nums[i]);
        }
        res.push_back(que.front());
        for(int i=k;i&lt;nums.size();++i){
            que.pop(nums[i-k]);
            que.push(nums[i]);
            res.push_back(que.front());
        }
        return res;
    }
};
</code></pre><h2 id=347-top-k-frequent-elements>347. Top K Frequent Elements</h2><h3 id=7题目描述>7.题目描述</h3><p>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.</p><h3 id=7解题思路>7.解题思路</h3><p>很简单，我们可以先用哈希表统计频率，然后再对哈希表按value进行排序……</p><pre><code class=language-python>class Solution:
    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:
            count_map = {}
            for i in nums:
                if count_map.get(i):
                    count_map[i]+=1
                else:
                    count_map[i]=1
            sorted_map = sorted(count_map.items(), key = lambda kv:kv[1],reverse = True)
            return [x[0] for x in sorted_map[:k]]
</code></pre><p>是不是少了些什么……如果不用Python呢？</p><p>我们可以用优先队列解决这个问题</p><p>优先队列，就是一个<strong>堆</strong></p><p>那么，什么是堆呢？</p><p>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</p><p>如果父亲结点是大于等于左右孩子就是<em>大顶堆</em>，小于等于左右孩子就是<em>小顶堆</em>。</p><p>对堆push时，会弹出头节点，因此使用大顶堆，每次都会弹出最大的元素</p><p>使用小顶堆，每次排出最小的元素即可，这样留下的就是最大的K个元素</p><p>这样，也比进行排序效率高，我们只需要维护k个有序序列就好</p><h3 id=7代码实现>7.代码实现</h3><p>Cpp:</p><pre><code class=language-cpp>class Solution {
public:
    class myCompare{
    public:
        bool operator()(const pair&lt;int,int&gt;&amp; lhs, const pair&lt;int,int&gt;&amp; rhs){
            return lhs.second&gt;rhs.second;
        }
    };
    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {
        // 哈希表统计元素频率
        unordered_map&lt;int,int&gt; map;
        for(int i=0;i&lt;nums.size();++i){
            map[nums[i]]++;
        }

        priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,myCompare&gt; pri_que;

        // 扫描
        for(unordered_map&lt;int,int&gt;::iterator it = map.begin();it!=map.end();it++){
            pri_que.push(*it);
            // 用k大小的小顶堆扫描
            if(pri_que.size()&gt;k){
            // 大于k就弹出最小值
                pri_que.pop();
            }
        }

        // 倒序输出
        vector&lt;int&gt; res(k);
        for (int i=k-1;i&gt;=0;i--){
            res[i]=pri_que.top().first;
            pri_que.pop();
        }
        return res;
    }
};
</code></pre><p>结束了，撒花花~</p></div></article><div class="license markdown-body"><blockquote><p>除特殊注明部分，本站内容采用 <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a> 进行许可。</p></blockquote></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/mood/>Mood</a></li><li><a href=/friends/>Friends</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/shudorcl target=_blank><span>GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/%E5%8A%9B%E6%89%A3/>力扣</a></span>
<span><a href=/tags/%E6%9D%82%E7%89%A9/>杂物</a></span>
<span><a href=/tags/%E7%AC%94%E8%AE%B0/>笔记</a></span>
<span><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/>计算机</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#232implement-queue-using-stacks>232.Implement Queue using Stacks</a><ul><li><a href=#1题目描述>1.题目描述</a></li><li><a href=#1解题思路>1.解题思路</a></li><li><a href=#1代码实现>1.代码实现</a></li></ul></li><li><a href=#225-implement-stack-using-queues>225. Implement Stack using Queues</a><ul><li><a href=#2题目描述>2.题目描述</a></li><li><a href=#2解题思路>2.解题思路</a></li><li><a href=#2代码实现>2.代码实现</a></li><li><a href=#一个队列的解法>一个队列的解法</a></li></ul></li><li><a href=#20-valid-parentheses>20. Valid Parentheses</a><ul><li><a href=#3题目描述>3.题目描述</a></li><li><a href=#3解题思路>3.解题思路</a></li><li><a href=#3代码实现>3.代码实现</a></li></ul></li><li><a href=#1047-remove-all-adjacent-duplicates-in-string>1047. Remove All Adjacent Duplicates In String</a><ul><li><a href=#4题目描述>4.题目描述</a></li><li><a href=#4解题思路>4.解题思路</a></li><li><a href=#4代码实现>4.代码实现</a></li></ul></li><li><a href=#150-evaluate-reverse-polish-notation>150. Evaluate Reverse Polish Notation</a><ul><li><a href=#5题目描述>5.题目描述</a></li><li><a href=#5解题思路>5.解题思路</a></li><li><a href=#5代码实现>5.代码实现</a></li></ul></li><li><a href=#239-sliding-window-maximum>239. Sliding Window Maximum</a><ul><li><a href=#6题目描述>6.题目描述</a></li><li><a href=#6解题思路>6.解题思路</a></li><li><a href=#6代码实现>6.代码实现</a></li></ul></li><li><a href=#347-top-k-frequent-elements>347. Top K Frequent Elements</a><ul><li><a href=#7题目描述>7.题目描述</a></li><li><a href=#7解题思路>7.解题思路</a></li><li><a href=#7代码实现>7.代码实现</a></li></ul></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/mood/>Mood</a></li><li><a href=/friends/>Friends</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/shudorcl target=_blank><span>GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/%E5%8A%9B%E6%89%A3/>力扣</a></span>
<span><a href=/tags/%E6%9D%82%E7%89%A9/>杂物</a></span>
<span><a href=/tags/%E7%AC%94%E8%AE%B0/>笔记</a></span>
<span><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/>计算机</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#232implement-queue-using-stacks>232.Implement Queue using Stacks</a><ul><li><a href=#1题目描述>1.题目描述</a></li><li><a href=#1解题思路>1.解题思路</a></li><li><a href=#1代码实现>1.代码实现</a></li></ul></li><li><a href=#225-implement-stack-using-queues>225. Implement Stack using Queues</a><ul><li><a href=#2题目描述>2.题目描述</a></li><li><a href=#2解题思路>2.解题思路</a></li><li><a href=#2代码实现>2.代码实现</a></li><li><a href=#一个队列的解法>一个队列的解法</a></li></ul></li><li><a href=#20-valid-parentheses>20. Valid Parentheses</a><ul><li><a href=#3题目描述>3.题目描述</a></li><li><a href=#3解题思路>3.解题思路</a></li><li><a href=#3代码实现>3.代码实现</a></li></ul></li><li><a href=#1047-remove-all-adjacent-duplicates-in-string>1047. Remove All Adjacent Duplicates In String</a><ul><li><a href=#4题目描述>4.题目描述</a></li><li><a href=#4解题思路>4.解题思路</a></li><li><a href=#4代码实现>4.代码实现</a></li></ul></li><li><a href=#150-evaluate-reverse-polish-notation>150. Evaluate Reverse Polish Notation</a><ul><li><a href=#5题目描述>5.题目描述</a></li><li><a href=#5解题思路>5.解题思路</a></li><li><a href=#5代码实现>5.代码实现</a></li></ul></li><li><a href=#239-sliding-window-maximum>239. Sliding Window Maximum</a><ul><li><a href=#6题目描述>6.题目描述</a></li><li><a href=#6解题思路>6.解题思路</a></li><li><a href=#6代码实现>6.代码实现</a></li></ul></li><li><a href=#347-top-k-frequent-elements>347. Top K Frequent Elements</a><ul><li><a href=#7题目描述>7.题目描述</a></li><li><a href=#7解题思路>7.解题思路</a></li><li><a href=#7代码实现>7.代码实现</a></li></ul></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2022-2023
<a href=https://shudorcl.github.io>dorcl</a>
| <a href=https://github.com/shudorcl/shudorcl.github.io>Source code</a>
| 基于 <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a> 构建</span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ==" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js integrity="sha512-LCKPTo0gtJ74zCNMbWw04ltmujpzSR4oW+fgN+Y1YclhM5ZrHCZQAJE4quEodcI/G122sRhSGU2BsSRUZ2Gu3w==" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js integrity="sha512-GP4x8UWxWyh4BMbyJGOGneiTbkrWEF5izsVJByzVLodP8CuJH/n936+yQDMJJrOPUHLgyPbLiGw2rXmdvGdXHA==" crossorigin=anonymous></script>
<script defer src=/assets/js/fuji.min.645f1123be695831f419ab54c1bcba327325895c740014006e57070d4f3e5d6b553e929c4b46f40ea707249e9c7f7c2a446d32a39ce7319f80a34525586a8e0f.js integrity="sha512-ZF8RI75pWDH0GatUwby6MnMliVx0ABQAblcHDU8+XWtVPpKcS0b0DqcHJJ6cf3wqRG0yo5znMZ+Ao0UlWGqODw=="></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css integrity="sha512-07YhC3P4/vS5HdgGuNAAeIxb5ee//efgRNo5AGdMtqFBUPYOdQG/sDK0Nl5qNq94kdEk/Pvu8pmN4GYUeucUkw==" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js integrity="sha512-aMDiFsrEV3KzAn9EHwyBRS7y1APjZWt/Z/73ukLN2Ca2KcGGzlOQFQSnfOdnEcehpwMaQ8edlDB/0cMX2GsHbg==" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js integrity="sha512-ZA/RPrAo88DlwRnnoNVqKINnQNcWERzRK03PDaA4GIJiVZvGFIWQbdWCsUebMZfkWohnfngsDjXzU6PokO4jGw==" crossorigin=anonymous></script>
<script>renderMathInElement(document.querySelector("div.content"),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})</script></body></html>