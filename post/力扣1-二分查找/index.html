<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.110.0"><link rel=apple-touch-icon sizes=180x180 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-16x16.png><link rel=manifest href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/site.webmanifest><link rel=mask-icon href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/safari-pinned-tab.svg color=#8aa2d3><link rel="shortcut icon" href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon.ico><meta name=theme-color content="#ffffff"><title>力扣数组 - dorcl's Blog</title><meta name=author content="dorcl"><meta name=description content="A minimal Hugo theme with nice theme color."><meta name=keywords content="力扣"><meta property="og:title" content="力扣数组"><meta name=twitter:title content="力扣数组"><meta property="og:type" content="article"><meta property="og:url" content="https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A31-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"><meta property="og:description" content="虽然已经决定了申不上就在家里啃老，但是做点lc总归没有坏处。"><meta name=twitter:description content="虽然已经决定了申不上就在家里啃老，但是做点lc总归没有坏处。"><meta property="og:image" content="https://shudorcl.github.io/img/og.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shudorcl.github.io/img/og.png"><meta property="article:published_time" content="2022-07-25T10:45:03+08:00"><meta property="article:modified_time" content="2022-07-25T10:45:03+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://shudorcl.github.io/assets/css/fuji.min.css></head><body data-theme=auto data-theme-auto=true><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://shudorcl.github.io>dorcl's Blog</a>
<span class=title-sub>To The Unlimited Future...</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://shudorcl.github.io/post/%E5%8A%9B%E6%89%A31-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/>力扣数组</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2022-07-25</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;3440 words</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/%E5%8A%9B%E6%89%A3>力扣</a>&nbsp;</span></div><div class="post-content markdown-body"><p>虽然已经决定了申不上就在家里啃老，但是做点lc总归没有坏处。</p><p>这里直接按照<a href=https://programmercarl.com target=_blank>代码随想录</a>的顺序做题，不多一天一道这样。</p><p>不过作者给公众号知识星球导流和在豆瓣刷好评这些行为实在是太败我好感了。。。</p><h2 id=二分查找>二分查找</h2><h3 id=题目描述>题目描述</h3><p>Given an array of integers nums which is sorted in <strong>ascending</strong> order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
You must write an algorithm with O(log n) runtime complexity.</p><p>Example 1:</p><pre><code>Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4
</code></pre><p>Example 2:</p><pre><code>Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1
</code></pre><p>主要是注意题目的降序</p><h2 id=解题思路>解题思路</h2><p>作为上过数据结构的人，二分查找大概的思想还是记得的，无非是比较中间值，大于就取后半边，小于就取前半边，但是，在实际写代码的时候就犯难了。。。一开始想用递归做，后面发现根本不会写，果然没训练过就是这种水平。</p><p>我当然知道自己什么水平，于是马上去<a href=https://oi-wiki.org/basic/binary/ target=_blank>oiwiki</a>复习了一番，并把它的CPP模板改成了Go</p><pre><code class=language-go>func search(nums []int, target int) int {
    ret,mid:=-1,0
    start,end:=0,len(nums)-1
    for start&lt;=end{
        mid = start+((end-start)&gt;&gt;1)
        if nums[mid]&lt;target{
            start = mid+1
        } else if nums[mid]&gt;target{
            end = mid-1
        } else{
            ret = mid
            break
        }
    }
    return ret
}
</code></pre><p>唔，就我的理解而言，迭代方式的二分查找主要是根据查找结果更新<code>start</code>/<code>end</code>从而更新<code>mid</code></p><p>这里有两个点值得一提，一个是<code>len(nums)</code>理所当然会导致越界，需要<code>-1</code>，果然我还是急躁鲁莽，没救了</p><p>还有就是oiwiki上取平均用的是<code>(end-start)>>1</code>，我们知道，右移n位相当于除以$2^n$，是非常妙的避免溢出的方法！</p><p>（等等，为什么会溢出）</p><p>（这里应该还有递归写法，但是先摸了）</p><p>作为随时可能鸽的lc之旅的开始。。。今天就这些了！玩游戏！</p><h2 id=移除元素>移除元素</h2><h3 id=题目描述-1>题目描述</h3><p>Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.</p><p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.</p><p>Return k after placing the final result in the first k slots of nums.</p><p>Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.</p><p>Ex1.</p><pre><code class=language-bash>Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2,_,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).
</code></pre><h3 id=解题思路-1>解题思路</h3><p>一看题目当然懵了，不开空间怎么做。于是去看了看标签和提示，大概就是告诉我们可以用双指针来做，于是我马上去搜索双指针，找几个博客稍微看看。</p><p>五分钟后，很好，我大概了解了，于是在几次提交失败后整出了这样的代码</p><pre><code class=language-go>func removeElement(nums []int, val int) int {
    tail:=len(nums)-1
    for  tail&gt;=0 {
        if nums[tail]!=val{
            break
        }
        tail--
    }
    for head:=0;head&lt;=tail;head++{
        if nums[head]==val{
            nums[head]=nums[tail]
            tail--
        }
    }
    return tail+1
}
</code></pre><p>毫无疑问这当然是错的</p><p>怎么想的呢，主要是想到可以把重复的元素移到后面，但是这样实际上忽略了一点，就是不能保证后面的元素不是需要移除的，然后沿着这个错误的思路下去思考，就感觉完全不会写了，于是看了看评论区&mldr;</p><pre><code class=language-go>func removeElement(nums []int, val int) int {
    tail:=0
    for head:=0;head&lt;len(nums);head++{
        if nums[head]!=val{
            nums[tail]=nums[head]
            tail++
        }
    }
    return tail
}
</code></pre><p>简单非常多！</p><p>这样实际上才算是典型的双指针，一个快一个慢，因为我们考虑的只是输出数组的长度，那么，只要<code>nums[head]!=val</code>，就把需要输出的元素向前移动，双指针一起向前移动，反之，则<code>tail</code>不移动，不将其纳入输出元素中。</p><p>然后再看看力扣官方题解中的第二种解法&mldr;</p><pre><code class=language-go>func removeElement(nums []int, val int) int {
    left, right := 0, len(nums)
    for left &lt; right {
        if nums[left] == val {
            nums[left] = nums[right-1]
            right--
        } else {
            left++
        }
    }
    return left
}
</code></pre><p>？</p><p>前面所说，问题在于<em>不能保证后面的元素不是需要移除的</em>，这里则给出了解决的方法，如果飞过去的元素依然等于val，那么<code>left</code>就不进行移动，继续让<code>right</code>往下查找元素，这样，当两个指针交会时，结果就出来了。</p><p>此外，还有一个暴力解法：</p><pre><code class=language-java>// 时间复杂度：O(n^2)
// 空间复杂度：O(1)
class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int size = nums.size();
        for (int i = 0; i &lt; size; i++) {
            if (nums[i] == val) { // 发现需要移除的元素，就将数组集体向前移动一位
                for (int j = i + 1; j &lt; size; j++) {
                    nums[j - 1] = nums[j];
                }
                i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位
                size--; // 此时数组的大小-1
            }
        }
        return size;

    }
};
</code></pre><h3 id=彩蛋python一刀秒>彩蛋：Python一刀秒</h3><p>论<strong>Python为什么是神</strong></p><pre><code class=language-python>class Solution:
    def removeElement(self, nums: List[int], val: int) -&gt; int:
        while val in nums:
            nums.remove(val)
        return len(nums)
</code></pre><p>好了，今天就这样了，该去背单词了！</p><p>&mldr;或许有空多做几道变式比较好</p><h2 id=有序数组的平方>有序数组的平方</h2><h3 id=题目描述-2>题目描述</h3><p>Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.</p><h3 id=解题思路-2>解题思路</h3><h4 id=暴力>暴力</h4><p>先平方再排序</p><pre><code class=language-go>func sortedSquares(nums []int) []int {
    for k,v:= range nums{
        nums[k]=v*v
    }
    length:=len(nums)
    for i:=0;i&lt;length;i++{
        for j:=0;j&lt;length-1-i;j++{
            if nums[j]&gt;nums[j+1]{
                nums[j],nums[j+1]=nums[j+1],nums[j]
            }
        }
    }
    return nums
}
</code></pre><p>不过这里实际上可以用<code>sort.Ints(ans)</code>来解决，我这里手写了一个冒泡排序，顺便当复习了）</p><h4 id=双指针>双指针</h4><p>然后看到题目有双指针，心想这次得整一下，尝试了几回后想到可以从非零位置开始，一个往左一个往右进行比较加入，两边到头后跳出循环</p><pre><code class=language-go>func sortedSquares(nums []int) []int {
    start,count:=0,0
    length:=len(nums)
    if length==1{
        nums[0]=nums[0]*nums[0]
        return nums
    }
    newNums:=make([]int,length)
    for k,v:= range nums{
        if v&gt;=0{
            start=k
            break
        }
    }
    left,right:=start-1,start
    for{
        leftValue:=nums[left]*nums[left]
        rightValue:=nums[right]*nums[right]
        if leftValue&lt;rightValue{
            newNums[count]=leftValue
            if left&gt;0{
            left--
            }
        }else{
            newNums[count]=rightValue
            if right&lt;length-1{
            right++
            }
        }
        count++
        if left==0&amp;&amp;right==length-1{
            break
        }
    }
    return newNums
}
</code></pre><p>但是，但是，它运行样例结果不对啊！</p><p>最后没有办法去看题解了</p><p>原来如此.jpg</p><pre><code class=language-go>func sortedSquares(nums []int) []int {
    start:=0
    length:=len(nums)
    if length==1{
        nums[0]=nums[0]*nums[0]
        return nums
    }
    ans:=make([]int,0,length)
    for k,v:= range nums{
        start=k
        if v&gt;=0{
            break
        }
    }
    for left,right:=start-1,start;left&gt;=0||right&lt;length;{
        if left&lt;0{
            ans = append(ans,nums[right]*nums[right])
            right++
        }   else if right==length{
            ans = append(ans,nums[left]*nums[left])
            left--
        }   else if nums[left]*nums[left]&lt;nums[right]*nums[right]{
            ans = append(ans,nums[left]*nums[left])
            left--
        }   else{
            ans = append(ans,nums[right]*nums[right])
            right++
        }
    }
    return ans
}
</code></pre><p>第一次遇到<code>[-5,-3,-2,-1]</code>时还无法通过，因为前面判断非负位置的时候没有考虑全负。。。</p><p>先这样发布了！要吃午饭了！</p><h2 id=长度最小的子数组>长度最小的子数组</h2><h3 id=题目描述-3>题目描述</h3><p><a href=https://leetcode.cn/problems/minimum-size-subarray-sum/ target=_blank>209. 长度最小的子数组</a></p><p>Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, &mldr;, numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.</p><h3 id=解题思路-3>解题思路</h3><p>首先看看标签！有<code>Silding Window</code>和<code>Prefix Sum</code>，显然是我完全不会的</p><p>于是先用暴力方法做一下</p><h4 id=暴力法>暴力法</h4><pre><code class=language-go>func minSubArrayLen(target int, nums []int) int {
    count,length,minlength:=0,0,len(nums)
    for i :=0;i&lt;len(nums);i++{
        count,length=0,0
        for v :=i;v&lt;len(nums);v++{
            count+=nums[v]
            length++
            if count&gt;target{
                break
            }
        }
        if length&lt;minlength{
            minlength=length
        }
    }
    return length
}
</code></pre><p>但是怎么都算得结果是1，懒得debug了，直接看题解！</p><pre><code class=language-go>func minSubArrayLen(s int, nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    ans := math.MaxInt32
    for i := 0; i &lt; n; i++ {
        sum := 0
        for j := i; j &lt; n; j++ {
            sum += nums[j]
            if sum &gt;= s {
                ans = min(ans, j - i + 1)
                break
            }
        }
    }
    if ans == math.MaxInt32 {
        return 0
    }
    return ans
}

func min(x, y int) int {
    if x &lt; y {
        return x
    }
    return y
}
</code></pre><p>（7月30日在这里断了，8月4日继续！）
好像思路差不多诶。。。</p><p>试下改一改边界条件之类的</p><pre><code class=language-go>func minSubArrayLen(target int, nums []int) int {
    count,length,minlength:=0,0,len(nums)
    if minlength==0{
        return 0
    }
    minlength = math.MaxInt32
    for i :=0;i&lt;len(nums);i++{
        count=0
        for v :=i;v&lt;len(nums);v++{
            count+=nums[v]
            if count&gt;=target{
                length = v-i+1
                if length&lt;minlength{
                    minlength=length
                }
                break
            }
        }
        if minlength == math.MaxInt32{
            return 0
        }
    }
    return minlength
}
</code></pre><p>从这里分析可以发现，一开始的做法有很多问题：</p><ol><li><p>忽视了题目已经明确给出条件为<strong>is greater than or equal to target</strong>，边界条件依然为＞</p></li><li><p>导致每次返回为1的原因之一，是每次循环都进行一次比较，自然是最短的为1的串成为答案</p></li><li><p>同样，应该返回的是<code>minlength</code>，而非<code>length</code>，大概是没救了罢（大悲）</p></li></ol><p>题解很好，但是TLE了</p><p>接着我们看看题解介绍的其他方法（咕）</p><h4 id=滑动窗口>滑动窗口</h4><p>和前面几篇的双指针差不多，一前一后，前指针先往前扫描，如果<code>sum>=target</code>则记录长度，后指针再往前收缩，如此反复。</p><p>试一下自己写。。。</p><p>惹啊，不会，于是决定摆烂看代码随想录的视频</p><pre><code class=language-go>func minSubArrayLen(target int, nums []int) int {
    ans := math.MaxInt32
    n:=len(nums)
    sum:=0
    for i,j:=0,0;i&lt;n;i++{
        sum+=nums[i]                // 扫描到sum&gt;=target
        for sum&gt;=target{            // 如果sum&gt;=target，则更新
            subLength := i-j+1      // 计算长度
            sum-=nums[j]            // 减去收缩的元素
            if subLength&lt;ans{       // 此时，如果依然满足sum&gt;=target，则更新答案
                ans = subLength
            }
            j++                     // 继续收缩
        }                           // 如果不满足sum&gt;=target了呢？那么前指针向前继续扫描
    }
    if ans==math.MaxInt32{          // 如果ans值没有变化，则赋0
        ans = 0
    }
    return ans
}
</code></pre><p>至少有讲解视频，之前败的好感回来了一些。。。</p><h4 id=前缀和二分查找>前缀和+二分查找</h4><p>首先，什么是前缀和？因为太晚了今天先这样了，我要睡觉了！</p><p>看看<a href=https://oi-wiki.org/basic/prefix-sum/ target=_blank>OiWiki</a>怎么说：</p><blockquote><p>前缀和
定义
前缀和可以简单理解为「数列的前n项的和」，是一种重要的预处理方式，能大大降低查询的时间复杂度。</p></blockquote><p>噢，原来是这样啊（棒读）</p><p>大概就是处理出一个前缀和数组<code>sum []int</code>，然后对它进行二分查找，找到一个<code>sum[i]-sum[j]>=target</code>的位置。。。</p><p>看了看没太看懂，摸了</p><h2 id=螺旋矩阵ii>螺旋矩阵II</h2><h3 id=题目描述-4>题目描述</h3><blockquote><p>Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.</p></blockquote><h3 id=解题思路-4>解题思路</h3><p>看起来稀松平常，但是——这个东西怎么遍历啊！</p><p>完全不懂，于是直接看题解吧</p><p>看了看<a href="https://www.bilibili.com/video/BV1SL4y1N7mV?share_source=copy_web" target=_blank>视频解析</a>后，我已经完全明白了！</p><p>非常简单，就是剥洋葱！循环一个外圈后，再按照这样的模式去循环内圈！</p><p>那么，外圈怎么循环呢？参考视频中的思路，就是每条边遍历首个节点，但是不遍历最后一个节点！</p><p>OK，那么代码试一下！</p><pre><code class=language-go>func generateMatrix(n int) [][]int {
    ans := make([][]int, n)
    for i := range ans {
        ans[i] = make([]int, n)
    }
    count := 1
    for i:=0;i&lt;n/2;i++{
        // 一次循环一个外圈
        // 右
        for j:=i;j&lt;n-i-1;j++{
            ans[i][j]=count
            count++
        }
        // 下
        for j:=i;j&lt;n-i-1;j++{
            ans[j][n-i-1]=count
            count++
        }
        // 左
        for j:=n-i-1;j&gt;i;j--{
            ans[n-i-1][j]=count
            count++
        }
        // 上
        for j:=n-i-1;j&gt;i;j--{
            ans[j][i]=count
            count++
        }
    }
    // 如果是奇数补上中心
    if n%2==1{
        ans[n/2][n/2]=n*n
    }
    return ans
}
</code></pre><p>惹，第一次提交忘记加上补中心了。。。</p><p>值得一提的是，这里的<code>i</code>实际上身兼多职，如果用一种比较啰嗦的方式写的话可以是这样</p><pre><code class=language-go>func generateMatrix(n int) [][]int {
    ans := make([][]int, n)
    for i := range ans {
        ans[i] = make([]int, n)
    }
    count := 1
    start := 0
    offset := 0
    for i:=0;i&lt;n/2;i++{
        // 一次循环一个外圈
        // 右
        for j:=start;j&lt;n-offset-1;j++{
            ans[start][j]=count
            count++
        }
        // 下
        for j:=start;j&lt;n-offset-1;j++{
            ans[j][n-offset-1]=count
            count++
        }
        // 左
        for j:=n-offset-1;j&gt;start;j--{
            ans[n-offset-1][j]=count
            count++
        }
        // 上
        for j:=n-offset-1;j&gt;start;j--{
            ans[j][start]=count
            count++
        }
        start++
        offset++
    }
    // 如果是奇数补上中心
    if n%2==1{
        ans[n/2][n/2]=n*n
    }
    return ans
}
</code></pre><p>这里就比较清晰了，每一次循环的起始位置<code>start</code>，每次循环的末位置偏移<code>offset</code>和循环轮次<code>i</code>都是每轮加一，所以自然可以自增！</p><p>好了，今天就这样了，该学英语了！</p></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p></blockquote></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/mood/>Mood</a></li><li><a href=/friends/>Friends</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/shudorcl target=_blank><span>GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/%E5%8A%9B%E6%89%A3/>力扣</a></span>
<span><a href=/tags/%E6%9D%82%E7%89%A9/>杂物</a></span>
<span><a href=/tags/%E7%AC%94%E8%AE%B0/>笔记</a></span>
<span><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/>计算机</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#二分查找>二分查找</a><ul><li><a href=#题目描述>题目描述</a></li></ul></li><li><a href=#解题思路>解题思路</a></li><li><a href=#移除元素>移除元素</a><ul><li><a href=#题目描述-1>题目描述</a></li><li><a href=#解题思路-1>解题思路</a></li><li><a href=#彩蛋python一刀秒>彩蛋：Python一刀秒</a></li></ul></li><li><a href=#有序数组的平方>有序数组的平方</a><ul><li><a href=#题目描述-2>题目描述</a></li><li><a href=#解题思路-2>解题思路</a></li></ul></li><li><a href=#长度最小的子数组>长度最小的子数组</a><ul><li><a href=#题目描述-3>题目描述</a></li><li><a href=#解题思路-3>解题思路</a></li></ul></li><li><a href=#螺旋矩阵ii>螺旋矩阵II</a><ul><li><a href=#题目描述-4>题目描述</a></li><li><a href=#解题思路-4>解题思路</a></li></ul></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/mood/>Mood</a></li><li><a href=/friends/>Friends</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/shudorcl target=_blank><span>GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/%E5%8A%9B%E6%89%A3/>力扣</a></span>
<span><a href=/tags/%E6%9D%82%E7%89%A9/>杂物</a></span>
<span><a href=/tags/%E7%AC%94%E8%AE%B0/>笔记</a></span>
<span><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/>计算机</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#二分查找>二分查找</a><ul><li><a href=#题目描述>题目描述</a></li></ul></li><li><a href=#解题思路>解题思路</a></li><li><a href=#移除元素>移除元素</a><ul><li><a href=#题目描述-1>题目描述</a></li><li><a href=#解题思路-1>解题思路</a></li><li><a href=#彩蛋python一刀秒>彩蛋：Python一刀秒</a></li></ul></li><li><a href=#有序数组的平方>有序数组的平方</a><ul><li><a href=#题目描述-2>题目描述</a></li><li><a href=#解题思路-2>解题思路</a></li></ul></li><li><a href=#长度最小的子数组>长度最小的子数组</a><ul><li><a href=#题目描述-3>题目描述</a></li><li><a href=#解题思路-3>解题思路</a></li></ul></li><li><a href=#螺旋矩阵ii>螺旋矩阵II</a><ul><li><a href=#题目描述-4>题目描述</a></li><li><a href=#解题思路-4>解题思路</a></li></ul></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2020-2023
<a href=https://shudorcl.github.io>dorcl</a>
| <a href=https://github.com/shudorcl/shudorcl.github.io>Source code</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=/assets/js/fuji.min.js></script></body></html>